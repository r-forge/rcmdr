{
    "collab_server" : "",
    "contents" : "# last modified 2016-07-12 by J. Fox\n\n# utility functions\n\n# listing objects etc.\n\nlistDataSets <- function(envir=.GlobalEnv, ...) {\n    Vars <- ls(envir = envir, all.names = TRUE) # + PhG\n    if (length(Vars) == 0) return(Vars) # + PhG\n    \n    names(which(sapply(Vars, function(.x) is.data.frame(get(.x, envir=envir)))))\n}\n\nlistLinearModels <- function(envir=.GlobalEnv, ...) {\n    objects <- ls(envir=envir, ...)\n    if (length(objects) == 0) NULL\n    else objects[sapply(objects,\n        function(.x) \"lm\" == (class(get(.x, envir=envir))[1]))]\n}\n\nlistAOVModels <- function(envir=.GlobalEnv, ...) {\n    objects <- ls(envir=envir, ...)\n    if (length(objects) == 0) NULL\n    else objects[sapply(objects,\n        function(.x) \"aov\" == (class(get(.x, envir=envir))[1]))]\n}\n\nlistGeneralizedLinearModels <- function(envir=.GlobalEnv, ...) {\n    objects <- ls(envir=envir, ...)\n    if (length(objects) == 0) NULL\n    else objects[sapply(objects,\n        function(.x) \"glm\" == (class(get(.x, envir=envir))[1]))]\n}\n\nlistMultinomialLogitModels <- function(envir=.GlobalEnv, ...) {\n    objects <- ls(envir=envir, ...)\n    if (length(objects) == 0) NULL\n    else objects[sapply(objects,\n        function(.x) \"multinom\" == (class(get(.x, envir=envir))[1]))]\n}\n\nlistProportionalOddsModels <- function(envir=.GlobalEnv, ...) {\n    objects <- ls(envir=envir, ...)\n    if (length(objects) == 0) NULL\n    else objects[sapply(objects,\n        function(.x) \"polr\" == (class(get(.x, envir=envir))[1]))]\n}\n\nlistAllModels <- function(envir=.GlobalEnv, ...) {\n    objects <- ls(envir=envir, ...)\n    if (length(objects) == 0) NULL\n    else objects[sapply(objects,\n        function(.x) (class(get(.x, envir=envir))[1])) %in% getRcmdr(\"modelClasses\")]\n}\n\nactiveDataSet <- function(dsname, flushModel=TRUE, flushDialogMemory=TRUE){\n    .activeDataSet <- ActiveDataSet()\n    if (missing(dsname)) {\n        if (is.null(.activeDataSet)){\n            Message(message=gettextRcmdr(\"There is no active data set.\"), type=\"error\")\n            return(FALSE)\n        }\n        else return(.activeDataSet)\n    }\n    if (!is.data.frame(ds <- get(dsname, envir=.GlobalEnv))){\n        if (!exists.method(\"as.data.frame\", ds, default=FALSE)){\n            Message(message=paste(dsname, gettextRcmdr(\" is not a data frame and cannot be attached.\"),\n                sep=\"\"), type=\"error\")\n            tkfocus(CommanderWindow())\n            return()\n        }\n        command <- paste(dsname, \" <- as.data.frame(\", dsname, \")\", sep=\"\")\n        justDoIt(command)\n        logger(command)\n        Message(message=paste(dsname, gettextRcmdr(\" has been coerced to a data frame\"), sep=\"\"),\n            type=\"warning\")\n    }\n    varnames <- names(get(dsname, envir=.GlobalEnv))\n    newnames <- make.names(varnames)\n    badnames <- varnames != newnames\n    if (any(badnames)){\n        command <- paste(\"names(\", dsname, \") <- make.names(names(\",\n            dsname, \"))\", sep=\"\")\n        doItAndPrint(command)\n    }\n    if (!is.null(.activeDataSet) && getRcmdr(\"attach.data.set\")\n        && (length(grep(.activeDataSet, search())) !=0)) {\n        detach(pos = match(.activeDataSet, search()))\n        logger(paste(\"detach(\", .activeDataSet, \")\", sep=\"\"))\n    }\n    if (flushModel) {\n        putRcmdr(\".activeModel\", NULL)\n        RcmdrTclSet(\"modelName\", gettextRcmdr(\"<No active model>\"))\n        tkconfigure(getRcmdr(\"modelLabel\"), foreground=\"red\")\n    }\n    if (flushDialogMemory) putRcmdr(\"dialog.values\", list())\n    ActiveDataSet(dsname)\n    nrow <- nrow(get(dsname, envir=.GlobalEnv))\n    ncol <- ncol(get(dsname, envir=.GlobalEnv))\n    putRcmdr(\"nrow\", nrow)\n    putRcmdr(\"ncol\", ncol)\n    Message(sprintf(gettextRcmdr(\"The dataset %s has %d rows and %d columns.\"), dsname,\n        nrow, ncol), type=\"note\")\n    if (any(badnames)) Message(message=paste(dsname, gettextRcmdr(\" contains non-standard variable names:\\n\"),\n        paste(varnames[badnames], collapse=\", \"),\n        gettextRcmdr(\"\\nThese have been changed to:\\n\"), paste(newnames[badnames], collapse=\", \"),\n        sep=\"\"), type=\"warning\")\n    RcmdrTclSet(\"dataSetName\", paste(\" \", dsname, \" \"))\n    tkconfigure(getRcmdr(\"dataSetLabel\"), foreground=\"blue\")\n    activateMenus()\n    dsname\n}\n\n\nactiveModel <- function(model){\n    if (missing(model)) {\n        .activeModel <- ActiveModel()\n        if (is.null(.activeModel)){\n            Message(message=gettextRcmdr(\"There is no active model.\"), type=\"error\")\n            return(FALSE)\n        }\n        else return(.activeModel)\n    }\n    ActiveModel(model)\n    RcmdrTclSet(\"modelName\", paste(\" \", model, \" \"))\n    tkconfigure(getRcmdr(\"modelLabel\"), foreground=\"blue\")\n    activateMenus()\n    model\n}\n\nlistVariables <- function(dataSet=ActiveDataSet()) {\n    if(missing(dataSet)) {\n        Variables()\n    }\n    else {\n        vars <- names(get(dataSet, envir=.GlobalEnv))\n        if (getRcmdr(\"sort.names\")) sortVarNames(vars) else vars\n    }\n}\n\nlistFactors <- function(dataSet=ActiveDataSet()) {\n  if(missing(dataSet)) {\n    Factors()\n  }\n  else {\n    variables <- listVariables(dataSet)\n    variables[sapply(variables, function(.x){\n      .v <- eval(parse(text=.x), envir=get(dataSet, envir=.GlobalEnv))\n      is.factor(.v) || is.logical(.v) || is.character(.v)\n    })]\n  }\n}\n\nlistTwoLevelFactors <- function(dataSet=ActiveDataSet()){\n  if(missing(dataSet)) {\n    TwoLevelFactors()\n  }\n  else {\n    factors <- listFactors(dataSet)\n    if(length(factors) == 0) return(NULL)\n    factors[sapply(factors, function(.x){\n      .v <- eval(parse(text=.x), envir=get(dataSet, envir=.GlobalEnv))\n      2 == length(levels(.v)) || length(unique(.v)) == 2\n    })]\n  }\n}\n\nlistNumeric <- function(dataSet=ActiveDataSet()) {\n    if(missing(dataSet)) {\n        Numeric()\n    }\n    else {\n        variables <- listVariables(dataSet)\n        variables[sapply(variables,function(.x)\n            is.numeric(eval(parse(text=.x), envir=get(dataSet, envir=.GlobalEnv))))]\n    }\n}\n\ntrim.blanks <- function(text){\n    gsub(\"^\\ *\", \"\", gsub(\"\\ *$\", \"\", text))\n}\n\nis.valid.name <- function(x){\n    length(x) == 1 && is.character(x) && x == make.names(x)\n}\n\nis.valid.number <- function(string){\n    warn <- options(warn=-1)\n    on.exit(warn)\n    number <- as.numeric(string)\n    if (any(is.na(number))) FALSE else TRUE\n}\n\n# statistical\n\nCoef <- function(object, ...) UseMethod(\"Coef\")\n\nCoef.default <- function(object, ...) coef(object, ...)\n\nCoef.multinom <- function (object, ...) {\n    # the following adapted from nnet:\n    cf <- function (object, ...) \n    {\n        r <- length(object$vcoefnames)\n        if (length(object$lev) == 2L) {\n            coef <- object$wts[1L + (1L:r)]\n            names(coef) <- object$vcoefnames\n        }\n        else {\n            coef <- matrix(object$wts, nrow = object$n[3L], byrow = TRUE)[, \n                                                                          1L + (1L:r), drop = FALSE]\n            if (length(object$lev)) \n                dimnames(coef) <- list(object$lev, object$vcoefnames)\n            if (length(object$lab)) \n                dimnames(coef) <- list(object$lab, object$vcoefnames)\n            coef <- coef[-1L, , drop = FALSE]\n        }\n        coef\n    }\n    b <- cf(object, ...)\n    cn <- colnames(b)\n    rn <- rownames(b)\n    b <- as.vector(t(b))\n    names(b) <- as.vector(outer(cn, rn, function(c, r) paste(r, c, sep = \":\")))\n    b\n}\n\n\nConfint <- function(object, parm, level=0.95, ...) UseMethod(\"Confint\")\n\nConfint.default <- function(object, parm, level = 0.95, ...) {\n    ci <- confint(object, parm, level, ...)\n    ci <- cbind(Coef(object)[parm], ci)\n    colnames(ci)[1] <- \"Estimate\"\n    ci\n}\n\nConfint.glm <- function (object, parm, level=0.95, type=c(\"LR\", \"Wald\"), ...){\n    # adapted from stats:::confint.lm\n    type <- match.arg(type)\n    cf <- coef(object)\n    pnames <- names(cf)\n    if (type == \"LR\") \n        ci <- confint(object, parm, level, ...)\n    else {\n        if (missing(parm))\n            parm <- seq(along = pnames)\n        else if (is.character(parm))\n            parm <- match(parm, pnames, nomatch = 0)\n        a <- (1 - level)/2\n        a <- c(a, 1 - a)\n        pct <- paste(round(100 * a, 1), \"%\")\n        ci <- array(NA, dim = c(length(parm), 2), dimnames = list(pnames[parm],\n                                                                  pct))\n        ses <- sqrt(diag(vcov(object)))[parm]\n        fac <- qnorm(a)\n        ci[] <- cf[parm] + ses %o% fac\n    }\n    ci <- cbind(cf[parm], ci)\n    colnames(ci)[1] <- \"Estimate\"\n    fam <- family(object)\n    if (((fam$family == \"binomial\" || fam$family == \"quasibinomial\")  && fam$link == \"logit\")\n      || ((fam$family == \"poisson\" || fam$family == \"quasipoisson\")  && fam$link == \"log\"))\n      {\n        expci <- exp(ci)\n        colnames(expci)[1] <- \"exp(Estimate)\"\n        ci <- cbind(ci, expci)\n    }\n    ci\n}\n\nConfint.polr <- function (object, parm, level=0.95, ...){\n    # adapted from stats:::confint.lm\n    cf <- coef(object)\n    pnames <- names(cf)\n    if (missing(parm))\n        parm <- seq(along = pnames)\n    else if (is.character(parm))\n        parm <- match(parm, pnames, nomatch = 0)\n    a <- (1 - level)/2\n    a <- c(a, 1 - a)\n    pct <- paste(round(100 * a, 1), \"%\")\n    ci <- array(NA, dim = c(length(parm), 2), dimnames = list(pnames[parm],\n                                                              pct))\n    ses <- sqrt(diag(vcov(object)))[parm]\n    fac <- qnorm(a)\n    ci[] <- cf[parm] + ses %o% fac\n    ci <- cbind(cf[parm], ci)\n    colnames(ci)[1] <- \"Estimate\"\n    ci\n}\n\n# confint.multinom <- function (object, parm, level=0.95, ...){\n#     # adapted from stats:::confint.lm\n#     cf <- coef(object)\n#     if (is.vector(cf)) cf <- matrix(cf, nrow=1,\n#         dimnames=list(object$lev[2], names(cf)))\n#     pnames <- colnames(cf)\n#     if (missing(parm))\n#         parm <- seq(along = pnames)\n#     else if (is.character(parm))\n#         parm <- match(parm, pnames, nomatch = 0)\n#     a <- (1 - level)/2\n#     a <- c(a, 1 - a)\n#     ses <- matrix(sqrt(diag(vcov(object))),\n#         ncol=ncol(cf), byrow=TRUE)[,parm, drop=FALSE]\n#     cf <- cf[,parm, drop=FALSE]\n#     fac <- qnorm(a)\n#     ci <- abind::abind(cf + fac[1]*ses, cf + fac[2]*ses, along=3)\n#     dimnames(ci)[[3]] <- paste(round(100 * a, 1), \"%\")\n#     aperm(ci, c(2,3,1))[,,1]\n# }\n\nConfint.multinom <- function(object, parm, level = 0.95, ...) {\n    # adapted from stats:::confint.lm\n    cf <- Coef(object)\n    if (is.vector(cf)) cf <- matrix(cf, nrow=1,\n                                    dimnames=list(object$lev[2], names(cf)))\n    pnames <- colnames(cf)\n    if (missing(parm))\n        parm <- seq(along = pnames)\n    else if (is.character(parm))\n        parm <- match(parm, pnames, nomatch = 0)\n    a <- (1 - level)/2\n    a <- c(a, 1 - a)\n    ses <- matrix(sqrt(diag(vcov(object))),\n                  ncol=ncol(cf), byrow=TRUE)[,parm, drop=FALSE]\n    cf <- cf[,parm, drop=FALSE]\n    fac <- qnorm(a)\n    ci <- abind::abind(cf + fac[1]*ses, cf + fac[2]*ses, along=3)\n    dimnames(ci)[[3]] <- paste(round(100 * a, 1), \"%\")\n    ci <- aperm(ci, c(2,3,1))[,,1]\n    ci <- cbind(cf[parm], ci)\n    colnames(ci)[1] <- \"Estimate\"\n    ci\n}\n\n# Pager\n\n# this is slightly modified from tkpager to use the Rcmdr monospaced font\n#   and a white background\n\nRcmdrPager <- function (file, header, title, delete.file)\n{\n    title <- paste(title, header)\n    for (i in seq(along = file)) {\n        zfile <- file[[i]]\n        tt <- tktoplevel()\n        if (WindowsP()) tkwm.iconbitmap(tt, system.file(\"etc\", \"R-logo.ico\", package=\"Rcmdr\"))\n        tkwm.title(tt, if (length(title))\n            title[(i - 1)%%length(title) + 1]\n            else \"\")\n        txt <- tktext(tt, bg = \"white\", font = getRcmdr(\"logFont\"))\n        scr <- ttkscrollbar(tt, command = function(...) tkyview(txt,\n            ...))\n        tkconfigure(txt, yscrollcommand = function(...) tkset(scr,\n            ...))\n        tkpack(txt, side = \"left\", fill = \"both\", expand = TRUE)\n        tkpack(scr, side = \"right\", fill = \"y\")\n        chn <- tcl(\"open\", zfile)\n        tkinsert(txt, \"end\", gsub(\"_\\b\", \"\", tclvalue(tcl(\"read\",\n            chn))))\n        tcl(\"close\", chn)\n        tkconfigure(txt, state = \"disabled\")\n        tkmark.set(txt, \"insert\", \"0.0\")\n        tkfocus(txt)\n        if (delete.file)\n            tcl(\"file\", \"delete\", zfile)\n    }\n}\n\n# help functions\n\nhelpCommander <- function() {\n    PDF <- file.access(paste(file.path(path.package(package=\"Rcmdr\")[1], \"doc\"), \n        \"/\", gettextRcmdr(\"Commander\"), \".pdf\", sep=\"\"), mode=4)\n    if (PDF == 0){\n        browseURL(paste(file.path(path.package(package=\"Rcmdr\")[1], \"doc\"),\n            \"/\", gettextRcmdr(\"Commander\"), \".pdf\", sep=\"\"))\n    } \n    else if (as.numeric(R.Version()$major) >= 2) print(help(gettextRcmdr(\"Commander\")))\n    else help(gettextRcmdr(\"Commander\"))\n}\n\nhelpAboutCommander <- function() {\n    if (as.numeric(R.Version()$major) >= 2) print(help(\"Rcmdr\"))\n    else help(\"Rcmdr\")\n}\n\nbrowseManual <- function() {\n    browseURL(paste(file.path(path.package(package=\"Rcmdr\")[1], \"doc\"),\n        \"/\", gettextRcmdr(\"Getting-Started-with-the-Rcmdr\"), \".pdf\", sep=\"\"))\n}\n\nbrowseEnglishManual <- function() {\n    browseURL(paste(file.path(path.package(package=\"Rcmdr\")[1], \"doc\"),\n        \"/Getting-Started-with-the-Rcmdr.pdf\", sep=\"\"))\n}\n\nmanualTranslationP <- function(){\n    gettextRcmdr(\"Getting-Started-with-the-Rcmdr\") != \"Getting-Started-with-the-Rcmdr\"\n}\n\nbrowseRcmdrWebsite <- function() browseURL(\"http://socserv.socsci.mcmaster.ca/jfox/Misc/Rcmdr/\")\n\nbrowseRWebsite <- function() browseURL(\"http://www.r-project.org/\")\n\nbrowseRMarkdown <- function() browseURL(\"http://rmarkdown.rstudio.com/\")\n\n\n\n# functions for building dialog boxes\n\n# the following function is slightly modified, with permission, from Thomas Lumley, \n#   \"Programmer's Niche: Macros in R,\" R-News, Sept. 2001, Vol. 1, No. 3, pp.11-13.\ndefmacro <- function(..., expr){\n    expr <- substitute(expr)\n    len <- length(expr)\n    expr[3:(len+1)] <- expr[2:len]\n    ## delete \"macro\" variables starting in ..\n    expr[[2]] <- quote(on.exit(remove(list=objects(pattern=\"^\\\\.\\\\.\", all.names=TRUE))))\n    a <- substitute(list(...))[-1]\n    ## process the argument list\n    nn <- names(a)\n    if (is.null(nn)) nn <- rep(\"\", length(a))\n    for (i in seq(length.out=length(a))){\n        if (nn[i] == \"\") {\n            nn[i] <- paste(a[[i]])\n            msg <- paste(a[[i]], gettext(\"not supplied\", domain=\"R-Rcmdr\"))\n            a[[i]] <- substitute(stop(foo), list(foo = msg))\n        }\n    }\n    names(a) <- nn\n    a <- as.list(a)\n    ff <- eval(substitute(\n        function(){\n            tmp <- substitute(body)\n            eval(tmp, parent.frame())\n        },\n        list(body = expr)))\n    ## add the argument list\n    formals(ff) <- a\n    ## create a fake source attribute\n    mm <- match.call()\n    mm$expr <- NULL\n    mm[[1]] <- as.name(\"macro\")\n    expr[[2]] <- NULL # get \"local\" variable removal out of source\n    attr(ff, \"source\") <- c(deparse(mm), deparse(expr))\n    ## return the macro\n    ff\n}\n\nOKCancelHelp <- defmacro(window=top, helpSubject=NULL,  model=FALSE, reset=NULL, apply=NULL, helpPackage=NULL,\n    expr={\n        memory <- getRcmdr(\"retain.selections\")\n        button.strings <- c(\"OK\", \"Cancel\", \n                            if (!is.null(helpSubject)) \"Help\", \n                            if (!is.null(reset) && memory) \"Reset\", \n                            if (!is.null(apply)) \"Apply\")\n        width <- max(nchar(gettextRcmdr(button.strings)))\n        if (WindowsP()) width <- width + 2\n        buttonsFrame <- tkframe(window)\n        leftButtonsBox <- tkframe(buttonsFrame)\n        rightButtonsBox <- tkframe(buttonsFrame)\n        \n        OnOK <- function(){\n            putRcmdr(\"restoreTab\", FALSE)\n            if (getRcmdr(\"use.markdown\")) {\n                putRcmdr(\"startNewCommandBlock\", FALSE)\n                beginRmdBlock()\n            }\n            if (getRcmdr(\"use.knitr\")) {\n                putRcmdr(\"startNewKnitrCommandBlock\", FALSE)\n                beginRnwBlock()\n            }\n            setBusyCursor()\n            on.exit(setIdleCursor())\n            onOK()\n            if (model) putDialog (\"effectPlots\", NULL)\n            if (getRcmdr(\"use.markdown\")){\n                removeNullRmdBlocks()\n                putRcmdr(\"startNewCommandBlock\", TRUE)\n                if (getRcmdr(\"rmd.generated\")) {\n                    endRmdBlock()\n                    putRcmdr(\"rmd.generated\", FALSE)\n                }\n                removeNullRmdBlocks()\n            }\n            if (getRcmdr(\"use.knitr\")){\n                removeNullRnwBlocks()\n                putRcmdr(\"startNewKnitrCommandBlock\", TRUE)\n                if (getRcmdr(\"rnw.generated\")) {\n                    endRnwBlock()\n                    putRcmdr(\"rnw.generated\", FALSE)\n                }\n                removeNullRnwBlocks()\n            }\n            putRcmdr(\"rgl.command\", FALSE)\n        }\n        \n        OKbutton <- buttonRcmdr(rightButtonsBox, text=gettextRcmdr(\"OK\"), foreground=\"darkgreen\", width=width, command=OnOK, default=\"active\",\n            image=\"::image::okIcon\", compound=\"left\")\n        \n        onCancel <- function() {\n            if (exists(\".exit\")){\n                result <- .exit()\n                if (result == \"abort\") return()\n            }\n            putRcmdr(\"restoreTab\", FALSE)\n            if (model) putRcmdr(\"modelNumber\", getRcmdr(\"modelNumber\") - 1)\n            if (GrabFocus()) tkgrab.release(window)\n            tkdestroy(window)\n            putRcmdr(\"rgl.command\", FALSE)\n            tkfocus(CommanderWindow())\n        }\n        \n        cancelButton <- buttonRcmdr(rightButtonsBox, text=gettextRcmdr(\"Cancel\"), foreground=\"red\", width=width, command=onCancel, # borderwidth=3,\n            image=\"::image::cancelIcon\", compound=\"left\")\n        \n        if (!is.null(helpSubject)){\n            onHelp <- function() {\n                if (GrabFocus() && (!WindowsP())) tkgrab.release(window)\n                if (as.numeric(R.Version()$major) >= 2) print(help(helpSubject, package=helpPackage))\n                else help(helpSubject, package=helpPackage)\n            }\n            helpButton <- buttonRcmdr(leftButtonsBox, text=gettextRcmdr(\"Help\"), width=width, command=onHelp, # borderwidth=3,\n                image=\"::image::helpIcon\", compound=\"left\")\n        }\n        \n        if (!is.null(reset) && memory){\n            onReset <- function(){\n                ID <- window$ID\n                putRcmdr(\"cancelDialogReopen\", TRUE)\n                putRcmdr(\"open.dialog.here\", as.character(.Tcl(paste(\"winfo geometry\", ID))))\n                if (model) putRcmdr(\"modelNumber\", getRcmdr(\"modelNumber\") - 1)\n                putDialog(reset, NULL)\n                putDialog(reset, NULL, resettable=FALSE)\n                closeDialog()\n                eval(parse(text=paste(reset, \"()\")))\n                putRcmdr(\"open.dialog.here\", NULL)\n                putRcmdr(\"restoreTab\", FALSE)\n            }\n            resetButton <- buttonRcmdr(leftButtonsBox, text=gettextRcmdr(\"Reset\"), width=width, command=onReset,\n                image=\"::image::resetIcon\", compound=\"left\")\n        }\n        \n        if (!is.null(apply)){\n            onApply <- function(){\n                putRcmdr(\"restoreTab\", TRUE)\n                putRcmdr(\"cancelDialogReopen\", FALSE)\n                ID <- window$ID\n                putRcmdr(\"open.dialog.here\", as.character(.Tcl(paste(\"winfo geometry\", ID))))\n                if (getRcmdr(\"use.markdown\")) {\n                    putRcmdr(\"startNewCommandBlock\", FALSE)\n                    beginRmdBlock()\n                }\n                if (getRcmdr(\"use.knitr\")) {\n                    putRcmdr(\"startNewKnitrCommandBlock\", FALSE)\n                    beginRnwBlock()\n                }\n                setBusyCursor()\n                on.exit(setIdleCursor())\n                onOK()\n                putRcmdr(\"rgl.command\", FALSE)\n                if (getRcmdr(\"use.markdown\")){\n                    removeNullRmdBlocks()\n                    putRcmdr(\"startNewCommandBlock\", TRUE)\n                    if (getRcmdr(\"rmd.generated\")) {\n                        endRmdBlock()\n                        putRcmdr(\"rmd.generated\", FALSE)\n                    }\n                    removeNullRmdBlocks()\n                }\n                if (getRcmdr(\"use.knitr\")){\n                    removeNullRnwBlocks()\n                    putRcmdr(\"startNewKnitrCommandBlock\", TRUE)\n                    if (getRcmdr(\"rnw.generated\")) {\n                        endRnwBlock()\n                        putRcmdr(\"rnw.generated\", FALSE)\n                    }\n                    removeNullRnwBlocks()\n                }\n                if (getRcmdr(\"cancelDialogReopen\")){\n                    putRcmdr(\"cancelDialogReopen\", FALSE)\n                }\n                else{\n                    eval(parse(text=paste(apply, \"()\")))\n                    putRcmdr(\"open.dialog.here\", NULL)\n                }\n            }\n            applyButton <- buttonRcmdr(rightButtonsBox, text=gettextRcmdr(\"Apply\"), foreground=\"yellow\", width=width, command=onApply,\n                image=\"::image::applyIcon\", compound=\"left\")\n        }\n        \n        if(!WindowsP()) {\n            if (!is.null(apply)){\n                tkgrid(applyButton, cancelButton, OKbutton, sticky=\"w\")\n                tkgrid.configure(OKbutton, padx=c(6, 0))\n            }\n            else{\n                tkgrid(cancelButton, OKbutton, sticky=\"w\")\n            }\n            tkgrid.configure(cancelButton, padx=c(6, 6))\n        }\n        else {\n            if (!is.null(apply)){\n                tkgrid(OKbutton, cancelButton, applyButton, sticky=\"w\")\n                tkgrid.configure(applyButton, padx=c(6, 0))\n            }\n            else{\n                tkgrid(OKbutton, cancelButton, sticky=\"w\")\n            }\n            tkgrid.configure(OKbutton, padx=c(6, 6))\n        }\n        if (!is.null(reset) && memory) {\n            if (! is.null(helpSubject)){\n                tkgrid (helpButton, resetButton, pady=6)\n            }\n            else tkgrid (resetButton, pady=6)\n            if (!WindowsP()) tkgrid.configure(resetButton, padx=c(0, 6))\n        }\n        else if (! is.null(helpSubject)){\n            tkgrid(helpButton, pady=6)\n        }\n        tkgrid(leftButtonsBox, rightButtonsBox, pady=6, sticky=\"ew\")\n        if (!is.null(helpSubject)) tkgrid.configure(helpButton, padx=c(0, 18))\n        else if (!is.null(reset) && memory) tkgrid.configure(resetButton, padx=c(0, 18))\n        tkgrid.columnconfigure(buttonsFrame, 0, weight=1)\n        tkgrid.columnconfigure(buttonsFrame, 1, weight=1)\n        tkgrid.configure(leftButtonsBox, sticky=\"w\")\n        tkgrid.configure(rightButtonsBox, sticky=\"e\")\n    })\n\nsubOKCancelHelp <- defmacro(window=subdialog, helpSubject=NULL,\n    expr={\n        \n        button.strings <- c(\"OK\", \"Cancel\", \n                            if (!is.null(helpSubject)) \"Help\")\n        width <- max(nchar(gettextRcmdr(button.strings)))\n        if (WindowsP()) width <- width + 2\n        subButtonsFrame <- tkframe(window)\n        subLeftButtonsBox <- tkframe(subButtonsFrame)\n        subRightButtonsBox <- tkframe(subButtonsFrame)\n        subOKbutton <- buttonRcmdr(subRightButtonsBox, text=gettextRcmdr(\"OK\"), foreground=\"darkgreen\", width=width, command=onOKsub, default=\"active\",\n            image=\"::image::okIcon\", compound=\"left\")\n        onCancelSub <- function() {\n          if (exists(\".subexit\")){\n            .subexit()\n          }\n          if (GrabFocus()) tkgrab.release(window)\n          tkdestroy(window)\n          tkfocus(CommanderWindow())\n        }\n        subCancelButton <- buttonRcmdr(subRightButtonsBox, text=gettextRcmdr(\"Cancel\"), foreground=\"red\", width=width, command=onCancelSub,\n            image=\"::image::cancelIcon\", compound=\"left\") # borderwidth=3, \n        if (!is.null(helpSubject)){\n            onHelpSub <- function(){\n                if (GrabFocus() && (!WindowsP())) tkgrab.release(window)\n                if (as.numeric(R.Version()$major) >= 2) print(help(helpSubject))\n                else help(helpSubject)\n            }\n            subHelpButton <- buttonRcmdr(subLeftButtonsBox, text=gettextRcmdr(\"Help\"), width=width, command=onHelpSub, \n                image=\"::image::helpIcon\", compound=\"left\")\n        }\n        if(!WindowsP()) {\n            tkgrid(subCancelButton, subOKbutton, sticky=\"w\")\n            tkgrid.configure(subOKbutton, padx=c(6, 0))\n        }\n        else {\n            tkgrid(subOKbutton, subCancelButton, sticky=\"w\")\n            tkgrid.configure(subOKbutton, padx=c(0, 6))\n        }\n        if (! is.null(helpSubject)){\n            tkgrid(subHelpButton, pady=6, padx=c(0, 18))\n        }\n        tkgrid(subLeftButtonsBox, subRightButtonsBox, pady=6, sticky=\"ew\")\n        tkgrid.columnconfigure(subButtonsFrame, 0, weight=1)\n        tkgrid.columnconfigure(subButtonsFrame, 1, weight=1)\n        tkgrid.configure(subLeftButtonsBox, sticky=\"w\")\n        tkgrid.configure(subRightButtonsBox, sticky=\"e\")\n    })\n\ncheckActiveDataSet <- function(){\n    if (activeDataSet() == FALSE) {\n        tkfocus(CommanderWindow())\n        FALSE\n    }\n    else TRUE\n}\n\ncheckActiveModel <- function(){\n    if (activeModel() == FALSE) {\n        tkfocus(CommanderWindow())\n        FALSE\n    }\n    else TRUE\n}\n\ncheckFactors <- function(n=1){\n    if (length(Factors()) < n){\n        if (n > 1)\n            Message(message=sprintf(gettextRcmdr(\"There fewer than %d factors in the active data set.\"), n),\n                type=\"error\")\n        else Message(message=gettextRcmdr(\"There are no factors in the active data set.\"),\n            type=\"error\")\n        tkfocus(CommanderWindow())\n        FALSE\n    }\n    else TRUE\n}\n\ncheckTwoLevelFactors <- function(n=1){\n    if (length(TwoLevelFactors()) < n){\n        if (n > 1)\n            Message(message=sprintf(gettextRcmdr(\"There fewer than %d two-level factors in the active data set.\"), n),\n                type=\"error\")\n        else Message(message=gettextRcmdr(\"There are no two-level factors in the active data set.\"),\n            type=\"error\")\n        tkfocus(CommanderWindow())\n        FALSE\n    }\n    else TRUE\n}\n\ncheckNumeric <- function(n=1){\n    if (length(Numeric()) < n){\n        if (n > 1)\n            Message(message=sprintf(gettextRcmdr(\"There fewer than %d numeric variables in the active data set.\"), n),\n                type=\"error\")\n        else Message(message=gettextRcmdr(\"There are no numeric variables in the active data set.\"),\n            type=\"error\")\n        tkfocus(CommanderWindow())\n        FALSE\n    }\n    else TRUE\n}\n\ncheckVariables <- function(n=1){\n    if (length(Variables()) < n){\n        if (n > 1)\n            Message(message=sprintf(gettextRcmdr(\"There fewer than %d variables in the active data set.\"), n),\n                type=\"error\")\n        else Message(message=gettextRcmdr(\"There are no variables in the active data set.\"),\n            type=\"error\")\n        tkfocus(CommanderWindow())\n        FALSE\n    }\n    else TRUE\n}\n\ncommanderPosition <- function (){\n    ID <- CommanderWindow()$ID\n    as.numeric(c(tclvalue(.Tcl(paste(\"winfo rootx\", ID))),\n        tclvalue(.Tcl(paste(\"winfo rooty\", ID)))))\n}\n\ninitializeDialog <- defmacro(window=top, title=\"\", offset=10, preventCrisp, \n    use.tabs=FALSE, notebook=notebook, tabs=c(\"dataTab\", \"optionsTab\"),\n    suppress.window.resize.buttons=TRUE,\n    expr={\n        if (getRcmdr(\"crisp.dialogs\")) tclServiceMode(on=FALSE)\n        window <- tktoplevel(borderwidth=10)\n        if (use.tabs){\n            notebook <- ttknotebook(window)\n            for (tab in tabs) assign(tab, tkframe(window))\n        }\n        tkwm.title(window, title)\n        location <- getRcmdr(\"open.dialog.here\")\n        position <- if (!is.null(location)) location\n        else {\n            pos <- offset + commanderPosition() \n            if (any(pos < 0)) \"-50+50\"\n            else paste(\"+\", paste(pos, collapse=\"+\"), sep=\"\")\n        }\n        tkwm.geometry(window, position)\n        if (suppress.window.resize.buttons) tkwm.transient(window, CommanderWindow())\n    }\n)\n\ncloseDialog <- defmacro(window=top, release=TRUE,\n    expr={\n        if (release && GrabFocus()) tkgrab.release(window)\n        tkdestroy(window)\n    }\n)\n\ndialogSuffix <- defmacro(window=top, onOK=onOK, onCancel=onCancel, rows, columns, focus=top,\n    bindReturn=TRUE, preventGrabFocus=FALSE, preventDoubleClick=FALSE,\n    preventCrisp, \n    use.tabs=FALSE, notebook=notebook, tabs=c(\"dataTab\", \"optionsTab\"), tab.names=c(\"Data\", \"Options\"),\n    grid.buttons=FALSE, resizable=FALSE, force.wait=FALSE,\n    expr={\n        if (use.tabs){\n            for (i in 1:length(tabs)){\n                tkadd(notebook, get(tabs[i]), text=gettextRcmdr(tab.names[i]), padding=6, sticky=\"nsew\")\n            }\n            tkgrid(notebook, sticky=\"nsew\")\n        }\n        if (grid.buttons) tkgrid(buttonsFrame, sticky = \"ew\")\n        if (use.tabs && exists(\"dialog.values\") && !is.null(dialog.values$initial.tab) && getRcmdr(\"restoreTab\")) \n            tkselect(notebook, dialog.values$initial.tab)\n        .Tcl(\"update idletasks\")\n        tkwm.resizable(window, as.numeric(resizable), as.numeric(resizable))\n        if (bindReturn) tkbind(window, \"<Return>\", onOK)\n        tkbind(window, \"<Escape>\", onCancel)\n        if (getRcmdr(\"double.click\") && (!preventDoubleClick)) tkbind(window, \"<Double-ButtonPress-1>\", onOK)\n        tkwm.deiconify(window)\n        # focus grabs appear to cause problems for some dialogs\n        if (GrabFocus() && (!preventGrabFocus)) tkgrab.set(window)\n        tkfocus(focus)\n        if (getRcmdr(\"tkwait.dialog\") || force.wait) tkwait.window(window)\n        if (getRcmdr(\"crisp.dialogs\")) tclServiceMode(on=TRUE)\n    }\n)\n\nvariableListBox <- function(parentWindow, variableList=Variables(), bg=\"white\",\n    selectmode=\"single\", export=\"FALSE\", initialSelection=NULL, listHeight=getRcmdr(\"variable.list.height\"), title){\n    if (selectmode == \"multiple\") selectmode <- getRcmdr(\"multiple.select.mode\")\n    if (length(variableList) == 1 && is.null(initialSelection)) initialSelection <- 0\n    frame <- tkframe(parentWindow)\n    minmax <- getRcmdr(\"variable.list.width\")\n    listbox <- tklistbox(frame, height=min(listHeight, length(variableList)),\n        selectmode=selectmode, background=bg, exportselection=export, \n        width=min(max(minmax[1], 2 + nchar(variableList)), minmax[2]))\n    scrollbar <- ttkscrollbar(frame, command=function(...) tkyview(listbox, ...))\n    tkconfigure(listbox, yscrollcommand=function(...) tkset(scrollbar, ...))\n    for (var in variableList) tkinsert(listbox, \"end\", var)\n    if (is.numeric(initialSelection)) for (sel in initialSelection) tkselection.set(listbox, sel)\n    firstChar <- tolower(substr(variableList, 1, 1))\n    len <- length(variableList)\n    onLetter <- function(letter){\n        letter <- tolower(letter)\n        current <- 1 + round(as.numeric(unlist(strsplit(tclvalue(tkyview(listbox) ), \" \"))[1])*len)\n        mat <- match(letter, firstChar[-(1:current)])\n        if (is.na(mat)) return()\n        tkyview.scroll(listbox, mat, \"units\")\n    }\n    onA <- function() onLetter(\"a\")\n    onB <- function() onLetter(\"b\")\n    onC <- function() onLetter(\"c\")\n    onD <- function() onLetter(\"d\")\n    onE <- function() onLetter(\"e\")\n    onF <- function() onLetter(\"f\")\n    onG <- function() onLetter(\"g\")\n    onH <- function() onLetter(\"h\")\n    onI <- function() onLetter(\"i\")\n    onJ <- function() onLetter(\"j\")\n    onK <- function() onLetter(\"k\")\n    onL <- function() onLetter(\"l\")\n    onM <- function() onLetter(\"m\")\n    onN <- function() onLetter(\"n\")\n    onO <- function() onLetter(\"o\")\n    onP <- function() onLetter(\"p\")\n    onQ <- function() onLetter(\"q\")\n    onR <- function() onLetter(\"r\")\n    onS <- function() onLetter(\"s\")\n    onT <- function() onLetter(\"t\")\n    onU <- function() onLetter(\"u\")\n    onV <- function() onLetter(\"v\")\n    onW <- function() onLetter(\"w\")\n    onX <- function() onLetter(\"x\")\n    onY <- function() onLetter(\"y\")\n    onZ <- function() onLetter(\"z\")\n    for (letter in c(letters, LETTERS)){\n        tkbind(listbox, paste(\"<\", letter, \">\", sep=\"\"),\n            get(paste(\"on\", toupper(letter), sep=\"\")))\n    }\n    onClick <- function() tkfocus(listbox)\n    toggleSelection <- function(){\n        active <- tclvalue(tkindex(listbox, \"active\"))\n        selected <- tclvalue(tkcurselection(listbox))\n        if (selected == active) tkselection.clear(listbox, \"active\") else tkselection.set(listbox, \"active\")\n    }\n    tkbind(listbox, \"<ButtonPress-1>\", onClick)\n    if (selectmode == \"single\") tkbind(listbox, \"<Control-ButtonPress-1>\", toggleSelection)\n    tkgrid(labelRcmdr(frame, text=title, fg=getRcmdr(\"title.color\"), font=\"RcmdrTitleFont\"), columnspan=2, sticky=\"w\")\n    tkgrid(listbox, scrollbar, sticky=\"nw\")\n    tkgrid.configure(scrollbar, sticky=\"wns\")\n    tkgrid.configure(listbox, sticky=\"ewns\")\n    result <- list(frame=frame, listbox=listbox, scrollbar=scrollbar,\n        selectmode=selectmode, varlist=variableList)\n    class(result) <- \"listbox\"\n    result\n}\n\ngetSelection <- function(object) UseMethod(\"getSelection\")\n\ngetSelection.listbox <- function(object){\n    object$varlist[as.numeric(tkcurselection(object$listbox)) + 1]\n}\n\ngetFrame <- function(object) UseMethod(\"getFrame\")\n\ngetFrame.listbox <- function(object){\n    object$frame\n}\n\nvariableComboBox <- function(parentWindow, variableList=Variables(),\n                             export=\"FALSE\", state=\"readonly\",\n                             initialSelection=gettextRcmdr(\"<no variable selected>\"),\n                             title=\"\"){\n  variableList <- c(gettextRcmdr(\"<no variable selected>\"), variableList)\n  frame <- tkframe(parentWindow)\n  combovar <- tclVar()\n  tclvalue(combovar) <- initialSelection\n  combobox <- ttkcombobox(frame, values=variableList, textvariable=combovar, \n                          state=state, export=export)\n  firstChar <- tolower(substr(variableList, 1, 1))\n  onLetter <- function(letter){\n    letter <- tolower(letter)\n    current <- as.numeric(tcl(combobox, \"current\"))\n    current <- if (current == -1) 1 else current + 1\n    mat <- match(letter, firstChar[-(1:current)])\n    if (is.na(mat)) return()\n    tcl(combobox, \"current\", current + mat - 1)\n  }\n  onA <- function() onLetter(\"a\")\n  onB <- function() onLetter(\"b\")\n  onC <- function() onLetter(\"c\")\n  onD <- function() onLetter(\"d\")\n  onE <- function() onLetter(\"e\")\n  onF <- function() onLetter(\"f\")\n  onG <- function() onLetter(\"g\")\n  onH <- function() onLetter(\"h\")\n  onI <- function() onLetter(\"i\")\n  onJ <- function() onLetter(\"j\")\n  onK <- function() onLetter(\"k\")\n  onL <- function() onLetter(\"l\")\n  onM <- function() onLetter(\"m\")\n  onN <- function() onLetter(\"n\")\n  onO <- function() onLetter(\"o\")\n  onP <- function() onLetter(\"p\")\n  onQ <- function() onLetter(\"q\")\n  onR <- function() onLetter(\"r\")\n  onS <- function() onLetter(\"s\")\n  onT <- function() onLetter(\"t\")\n  onU <- function() onLetter(\"u\")\n  onV <- function() onLetter(\"v\")\n  onW <- function() onLetter(\"w\")\n  onX <- function() onLetter(\"x\")\n  onY <- function() onLetter(\"y\")\n  onZ <- function() onLetter(\"z\")\n  for (letter in c(letters, LETTERS)){\n    tkbind(combobox, paste(\"<\", letter, \">\", sep=\"\"),\n           get(paste(\"on\", toupper(letter), sep=\"\")))\n  }\n  tkgrid(labelRcmdr(frame, text=title, fg=getRcmdr(\"title.color\"), font=\"RcmdrTitleFont\"), sticky=\"w\") # , columnspan=2\n  tkgrid(combobox, sticky=\"nw\")\n  result <- list(frame=frame, combobox=combobox, varlist=variableList, combovar=combovar)\n  class(result) <- \"combobox\"\n  result\n}\n\ngetSelection.combobox <- function(object){\n  tclvalue(object$combovar)\n}\n\ngetFrame.combobox <- function(object){\n  object$frame\n}\n\n# This function modified based on code by Liviu Andronic (13 Dec 09) and on code by Milan Bouchet-Valat (29 Jun 12):\nradioButtons <- defmacro(window=top, name, buttons, values=NULL, initialValue=..values[1], labels, \n    title=\"\", title.color=getRcmdr(\"title.color\"), right.buttons=FALSE, command=function(){},\n    expr={\n        ..values <- if (is.null(values)) buttons else values\n        ..frame <- paste(name, \"Frame\", sep=\"\")\n        assign(..frame, tkframe(window))\n        ..variable <- paste(name, \"Variable\", sep=\"\")\n        assign(..variable, tclVar(initialValue))\n        if(title != \"\"){\n            tkgrid(labelRcmdr(eval(parse(text=..frame)), text=title, foreground=title.color, font=\"RcmdrTitleFont\"), columnspan=2, sticky=\"w\")\n        }\n        for (i in 1:length(buttons)) {\n            ..button <- paste(buttons[i], \"Button\", sep=\"\")\n            if (right.buttons) {\n                assign(..button, ttkradiobutton(eval(parse(text=..frame)), variable=eval(parse(text=..variable)), \n                    value=..values[i], command=command))\n                tkgrid(labelRcmdr(eval(parse(text=..frame)), text=labels[i], justify=\"left\"), eval(parse(text=..button)), sticky=\"w\")\n            }\n            else{\n                assign(..button, ttkradiobutton(eval(parse(text=..frame)), variable=eval(parse(text=..variable)), \n                    value=..values[i], text=labels[i], command=command))\n                tkgrid(eval(parse(text=..button)), sticky=\"w\")\n            }\n        }\n    }\n)\n\n\ncheckBoxes <- defmacro(window=top, frame, boxes, initialValues=NULL, labels, title=NULL, ttk=FALSE,\n    expr={\n        ..initialValues <- if (is.null(initialValues)) rep(\"1\", length(boxes)) else initialValues\n        assign(frame, if (ttk) ttklabelframe(window, labelwidget=tklabel(window, text=title, \n                                          font=\"RcmdrTitleFont\", foreground=getRcmdr(\"title.color\"))) else tkframe(window))\n        if (!is.null(title) && !ttk) tkgrid(labelRcmdr(eval(parse(text=frame)), text=title, fg=getRcmdr(\"title.color\"), font=\"RcmdrTitleFont\"), sticky=\"w\")\n        ..variables <- paste(boxes, \"Variable\", sep=\"\")\n        for (i in 1:length(boxes)) {\n            assign(..variables[i], tclVar(..initialValues[i]))\n            ..checkBox <- paste(boxes[i], \"CheckBox\", sep=\"\")\n            assign(..checkBox,\n                ttkcheckbutton(eval(parse(text=frame)), variable=eval(parse(text=..variables[i])), text=labels[i]))\n            tkgrid(eval(parse(text=..checkBox)), sticky=\"w\")\n        }\n    }\n)\n\ncheckReplace <- function(name, type=gettextRcmdr(\"Variable\")){\n    RcmdrTkmessageBox(message=sprintf(gettextRcmdr(\"%s %s already exists.\\nOverwrite %s?\"),\n        type, name, tolower(type)), icon=\"warning\", type=\"yesno\", default=\"no\")\n}\n\nerrorCondition <- defmacro(window=top, recall=NULL, message, model=FALSE,\n    expr={\n        putRcmdr(\"cancelDialogReopen\", TRUE)\n        if (model) putRcmdr(\"modelNumber\", getRcmdr(\"modelNumber\") - 1)\n        if (!is.null(window)){\n            if (GrabFocus()) tkgrab.release(window)\n            tkdestroy(window)\n        }\n        Message(message=message, type=\"error\")\n        if (!is.null(recall)) recall()\n        else tkfocus(CommanderWindow())\n    })\n\nsubsetBox <- defmacro(window=top, subset.expression=NULL, model=FALSE,\n    expr={\n        subsetVariable <- if (!is.null(subset.expression)) tclVar(gettextRcmdr(subset.expression))\n        else if (model){\n            if (currentModel && currentFields$subset != \"\")\n                tclVar(currentFields$subset) else tclVar(gettextRcmdr(\"<all valid cases>\"))\n        }\n        else tclVar(gettextRcmdr(\"<all valid cases>\"))\n        subsetFrame <- tkframe(window)\n        subsetEntry <- ttkentry(subsetFrame, width=\"20\", textvariable=subsetVariable)\n        subsetScroll <- ttkscrollbar(subsetFrame, orient=\"horizontal\",\n            command=function(...) tkxview(subsetEntry, ...))\n        tkconfigure(subsetEntry, xscrollcommand=function(...) tkset(subsetScroll, ...))\n        tkgrid(labelRcmdr(subsetFrame, text=gettextRcmdr(\"Subset expression\"), fg=getRcmdr(\"title.color\"), font=\"RcmdrTitleFont\"), sticky=\"w\")\n        tkgrid(subsetEntry, sticky=\"ew\")\n        tkgrid(subsetScroll, sticky=\"ew\")\n        tkgrid.columnconfigure(subsetFrame, 0, weight=1)\n    })\n\n\ngroupsBox <- defmacro(recall=NULL, label=gettextRcmdr(\"Plot by:\"), initialLabel=gettextRcmdr(\"Plot by groups\"),\n                      errorText=gettextRcmdr(\"There are no factors in the active data set.\"),\n                      variables=Factors(), plotLinesByGroup=FALSE, positionLegend=FALSE, plotLinesByGroupsText=gettextRcmdr(\"Plot lines by group\"),\n                      initialGroup=NULL, initialLinesByGroup=1, window=top,\n                      expr={\n                          env <- environment()\n                          .groups <- if (is.null(initialGroup)) FALSE else initialGroup\n                          .linesByGroup <- initialLinesByGroup == 1\n                          .groupsLabel <- tclVar(if (!is.null(initialGroup)) initialLabel else paste(initialLabel, \"...\", sep=\"\"))\n                          .factors <- variables\n                          onGroups <- function(){\n                              if (length(.factors) == 0){\n                                  errorCondition(recall=recall, message=errorText)\n                                  return()\n                              }\n                              initializeDialog(subdialog, title=gettextRcmdr(\"Groups\"))\n                              groupsBox <- variableListBox(subdialog, .factors, title=gettextRcmdr(\"Groups variable (pick one)\"),\n                                                           initialSelection=varPosn(initialGroup, \"factor\"))\n                              if (plotLinesByGroup){\n                                  linesByGroupFrame <- tkframe(subdialog)\n                                  linesByGroup <- tclVar(if(initialLinesByGroup == 1) \"1\" else \"0\")\n                                  linesCheckBox <- ttkcheckbutton(linesByGroupFrame, variable=linesByGroup)\n                                  tkgrid(labelRcmdr(linesByGroupFrame, text=plotLinesByGroupsText), linesCheckBox, sticky=\"w\")\n                              }\n                              onOKsub <- function() {\n                                  groups <- getSelection(groupsBox)\n                                  if (length(groups) == 0){\n                                      assign(\".groups\", FALSE, envir=env)\n                                      tclvalue(.groupsLabel) <- paste(gettextRcmdr(\"Plot by groups\"), \"...\", sep=\"\")\n                                      tkconfigure(groupsButton, foreground=\"black\")\n                                      if (GrabFocus()) tkgrab.release(subdialog)\n                                      tkdestroy(subdialog)\n                                      tkwm.deiconify(top)\n                                      if (GrabFocus()) tkgrab.set(top)\n                                      tkfocus(top)\n                                      tkwait.window(top)\n                                      return()\n                                  }\n                                  assign(\".groups\", groups, envir=env)\n                                  tclvalue(.groupsLabel) <- paste(label, groups)\n                                  tkconfigure(groupsButton, foreground=getRcmdr(\"title.color\"))\n                                  tkconfigure(groupsButton, font=\"RcmdrTitleFont\")\n                                  if (plotLinesByGroup) {\n                                      lines <- as.character(\"1\" == tclvalue(linesByGroup))\n                                      assign(\".linesByGroup\", lines, envir=env)\n                                  }\n                                  if (GrabFocus()) tkgrab.release(subdialog)\n                                  tkdestroy(subdialog)\n                                  tkwm.deiconify(top)\n                                  if (GrabFocus()) tkgrab.set(top)\n                                  tkfocus(top)\n                                  tkwait.window(top)\n                              }\n                              subOKCancelHelp()\n                              tkgrid(getFrame(groupsBox), sticky=\"nw\")\n                              if (plotLinesByGroup) tkgrid(linesByGroupFrame, sticky=\"w\")\n                              tkgrid(subButtonsFrame, sticky=\"ew\")\n                              if (positionLegend) tkgrid(labelRcmdr(subdialog, text=gettextRcmdr(\"Position legend with mouse click\"), fg=getRcmdr(\"title.color\"), font=\"RcmdrTitleFont\"))\n                              dialogSuffix(subdialog, onOK=onOKsub, focus=subdialog, force.wait=TRUE)\n                          }\n                          groupsFrame <- tkframe(window)\n                          groupsButton <- tkbutton(groupsFrame, textvariable=.groupsLabel, command=onGroups)\n                          if (!is.null(initialGroup)) tkconfigure(groupsButton, foreground=getRcmdr(\"title.color\"), font=\"RcmdrTitleFont\")\n                          tkgrid(groupsButton, sticky=\"we\")\n                          tkgrid.columnconfigure(groupsFrame, 0, weight=1)\n                      })\n\n\ngroupsLabel <- defmacro(frame=top, groupsBox=groupsBox, columnspan=1, initialText=NULL,\n    expr={\n        initial.label <- if (exists(\"dialog.values\")) dialog.values$initial.label else NULL\n        if  (is.null(initial.label)) {\n            group <- getSelection(groupsBox)\n            initial.label <- if (length(group) == 0) NULL \n            else {\n                levels <- eval(parse(text = paste(\"levels(\", ActiveDataSet(), \n                    \"$\", group, \")\", sep = \"\")))\n                paste(levels[1], \"-\", levels[2])\n            }\n        }\n        groupsFrame <- tkframe(frame)\n        .groupsLabel <- if (!is.null(initialText)) initialText \n        else if (is.null(initial.label)) gettextRcmdr(\"<No groups selected>\") \n        else initial.label\n        groupsLabel <- labelRcmdr(groupsFrame, text=.groupsLabel)\n        tkgrid(labelRcmdr(groupsFrame, text=gettextRcmdr(\"Difference: \"), fg=getRcmdr(\"title.color\"), font=\"RcmdrTitleFont\"), groupsLabel, sticky=\"w\")\n        tkgrid(groupsFrame, sticky=\"w\", columnspan=columnspan)\n        onSelect <- function(){\n            group <- getSelection(groupsBox)\n            if (length(group) == 0) {\n                .groupsLabel <<- gettextRcmdr(\"<No groups selected>\") \n            }\n            else {\n                levels <- eval(parse(text=paste(\"levels(\", ActiveDataSet(), \"$\", group, \")\", sep=\"\")))\n                .groupsLabel <<- paste(levels[1], \"-\", levels[2])\n            }\n            tkconfigure(groupsLabel, text=.groupsLabel)\n        }\n        tkbind(groupsBox$listbox, \"<ButtonRelease-1>\", onSelect)\n    })\n\nmodelFormula <- defmacro(frame=top, hasLhs=TRUE, rhsExtras=NULL, formulaLabel=gettextRcmdr(\"Model Formula\"),\n                         expr={\n  .rhsExtras <- if (is.null(rhsExtras)) hasLhs else rhsExtras\n  checkAddOperator <- function(rhs){\n    rhs.chars <- rev(strsplit(rhs, \"\")[[1]])\n    if (length(rhs.chars) < 1) return(FALSE)\n    check.char <- if ((rhs.chars[1] != \" \") || (length(rhs.chars) == 1))\n      rhs.chars[1] else rhs.chars[2]\n    !is.element(check.char, c(\"+\", \"*\", \":\", \"/\", \"-\", \"^\", \"(\", \"%\"))\n  }\n  .variables <- Variables()\n  word <- paste(\"\\\\[\", gettextRcmdr(\"factor\"), \"\\\\]\", sep=\"\")\n  variables <- paste(.variables,\n                     ifelse(is.element(.variables, Factors()), paste(\"[\", gettextRcmdr(\"factor\"), \"]\", sep=\"\"), \"\"))\n  xBox <- variableListBox(frame, variables, selectmode=\"multiple\", title=gettextRcmdr(\"Variables (double-click to formula)\"))\n  onDoubleClick <- if (!hasLhs){\n    function(){\n      var <- getSelection(xBox)\n      tkselection.clear(xBox$listbox, \"0\", \"end\")            \t\t\n      if (length(grep(word, var)) == 1) var <- sub(word, \"\",  var)\n      tkfocus(rhsEntry)\n      rhs <- tclvalue(rhsVariable)\n      rhs.chars <- rev(strsplit(rhs, \"\")[[1]])\n      check.char <- if (length(rhs.chars) > 0){\n        if ((rhs.chars[1] != \" \") || (length(rhs.chars) == 1))\n          rhs.chars[1] else rhs.chars[2]\n      }\n      else \"\"\n      tclvalue(rhsVariable) <- if (rhs == \"\" ||\n                                   is.element(check.char, c(\"+\", \"*\", \":\", \"/\", \"-\", \"^\", \"(\", \"%\")))\n        paste(rhs, var, sep=\"\")\n      else paste(rhs, \"+\", var)\n      tkicursor(rhsEntry, \"end\")\n      tkxview.moveto(rhsEntry, \"1\")\n    }\n  }\n  else{\n    function(){\n      var <- getSelection(xBox)\n      which <- tkcurselection(xBox$listbox)\n      tkselection.clear(xBox$listbox, \"0\", \"end\")\n      if (length(grep(word, var)) == 1) var <- sub(word, \"\",  var)\n      lhs <- tclvalue(lhsVariable)\n      if (lhs == \"\" || tclvalue(tkselection.present(lhsEntry)) == \"1\"){\n        tclvalue(lhsVariable) <- var\n        tkselection.clear(lhsEntry)\n        tkfocus(rhsEntry)\n      }\n      else {\n        tkfocus(rhsEntry)\n        rhs <- tclvalue(rhsVariable)\n        rhs.chars <- rev(strsplit(rhs, \"\")[[1]])\n        check.char <- if (length(rhs.chars) > 0){\n          if ((rhs.chars[1] != \" \") || (length(rhs.chars) == 1))\n            rhs.chars[1] else rhs.chars[2]\n        }\n        else \"\"\n        tclvalue(rhsVariable) <- if (rhs == \"\" ||\n                                     is.element(check.char, c(\"+\", \"*\", \":\", \"/\", \"-\", \"^\", \"(\", \"%\")))\n          paste(rhs, var, sep=\"\")\n        else paste(rhs, \"+\", var)\n      }\n      tkicursor(rhsEntry, \"end\")\n      tkxview.moveto(rhsEntry, \"1\")\n    }\n  }\n  tkbind(xBox$listbox, \"<Double-ButtonPress-1>\", onDoubleClick)\n  onPlus <- function(){\n    rhs <- tclvalue(rhsVariable)\n    var <- getSelection(xBox)\n    tkselection.clear(xBox$listbox, \"0\", \"end\")\t\t\t\t\t\t\t\t\t\t\n    if ((check <- !checkAddOperator(rhs)) && length(var) == 0) return()\n    if (length(var) > 1){\n      if (length(grep(word, var)) > 0) var <- sub(word, \"\",  var)\n      if (length(var) > 1) var <- paste(var, collapse=\" + \")\n    }\n    tclvalue(rhsVariable) <- paste(rhs, if (!check) \" + \", var, sep=\"\")\n    tkicursor(rhsEntry, \"end\")\n    tkxview.moveto(rhsEntry, \"1\")\n  }\n  onTimes <- function(){\n    rhs <- tclvalue(rhsVariable)\n    var <- getSelection(xBox)\n    tkselection.clear(xBox$listbox, \"0\", \"end\")\t\t\t\t\t\t\n    if ((check <- !checkAddOperator(rhs)) && length(var) == 0) return()\n    if (length(var) > 1){\n      if (length(grep(word, var)) > 0) var <- sub(word, \"\",  var)\n      var <- trim.blanks(var)\n      if (length(var) > 1) var <- paste(var, collapse=\"*\")\n      tclvalue(rhsVariable) <- paste(rhs, if (!check) \" + \", var, sep=\"\")\n    }\n    else tclvalue(rhsVariable) <- paste(rhs, if (!check) \"*\", sep=\"\")\n    tkicursor(rhsEntry, \"end\")\n    tkxview.moveto(rhsEntry, \"1\")\n  }\n  onColon <- function(){\n    rhs <- tclvalue(rhsVariable)\n    var <- getSelection(xBox)\n    tkselection.clear(xBox$listbox, \"0\", \"end\")\t\t\t\t\t\t\n    if ((check <- !checkAddOperator(rhs)) && length(var) == 0) return()\n    if (length(var) > 1){\n      if (length(grep(word, var)) > 0) var <- sub(word, \"\",  var)\n      var <- trim.blanks(var)\n      if (length(var) > 1) var <- paste(var, collapse=\":\")\n      tclvalue(rhsVariable) <- paste(rhs, if (!check) \" + \", var, sep=\"\")\n    }\n    else tclvalue(rhsVariable) <- paste(rhs, if (!check) \":\", sep=\"\")\n    tkicursor(rhsEntry, \"end\")\n    tkxview.moveto(rhsEntry, \"1\")\n  }\n  onSlash <- function(){\n    rhs <- tclvalue(rhsVariable)\n    if (!checkAddOperator(rhs)) return()\n    tclvalue(rhsVariable) <- paste(rhs, \"/\",  sep=\"\")\n    tkicursor(rhsEntry, \"end\")\n    tkxview.moveto(rhsEntry, \"1\")\n  }\n  onIn <- function(){\n    rhs <- tclvalue(rhsVariable)\n    if (!checkAddOperator(rhs)) return()\n    tclvalue(rhsVariable) <- paste(rhs, \"%in% \")\n    tkicursor(rhsEntry, \"end\")\n    tkxview.moveto(rhsEntry, \"1\")\n  }\n  onMinus <- function(){\n    rhs <- tclvalue(rhsVariable)\n    if (!checkAddOperator(rhs)) return()\n    tclvalue(rhsVariable) <- paste(rhs, \"- \")\n    tkicursor(rhsEntry, \"end\")\n    tkxview.moveto(rhsEntry, \"1\")\n  }\n  onPower <- function(){\n    rhs <- tclvalue(rhsVariable)\n    if (!checkAddOperator(rhs)) return()\n    tclvalue(rhsVariable) <- paste(rhs, \"^\", sep=\"\")\n    tkicursor(rhsEntry, \"end\")\n    tkxview.moveto(rhsEntry, \"1\")\n  }\n  onLeftParen <- function(){\n    tkfocus(rhsEntry)\n    rhs <- tclvalue(rhsVariable)\n    tclvalue(rhsVariable) <- paste(rhs, \"(\", sep=\"\")\n    tkicursor(rhsEntry, \"end\")\n    tkxview.moveto(rhsEntry, \"1\")\n  }\n  onRightParen <- function(){\n    rhs <- tclvalue(rhsVariable)\n    if (!checkAddOperator(rhs)) return()\n    tclvalue(rhsVariable) <- paste(rhs, \")\", sep=\"\")\n    tkicursor(rhsEntry, \"end\")\n    tkxview.moveto(rhsEntry, \"1\")\n  }\n  outerOperatorsFrame <- tkframe(frame)\n  operatorsFrame <- tkframe(outerOperatorsFrame)\n  splinePolyFrame <- tkframe(outerOperatorsFrame)\n  plusButton <- buttonRcmdr(operatorsFrame, text=\"+\", width=\"3\", command=onPlus)\n  timesButton <- buttonRcmdr(operatorsFrame, text=\"*\", width=\"3\", command=onTimes)\n  colonButton <- buttonRcmdr(operatorsFrame, text=\":\", width=\"3\", command=onColon)\n  slashButton <- buttonRcmdr(operatorsFrame, text=\"/\", width=\"3\", command=onSlash)\n  inButton <- buttonRcmdr(operatorsFrame, text=\"%in%\", width=\"5\", command=onIn)\n  minusButton <- buttonRcmdr(operatorsFrame, text=\"-\", width=\"3\", command=onMinus)\n  powerButton <- buttonRcmdr(operatorsFrame, text=\"^\", width=\"3\", command=onPower)\n  leftParenButton <- buttonRcmdr(operatorsFrame, text=\"(\", width=\"3\", command=onLeftParen)\n  rightParenButton <- buttonRcmdr(operatorsFrame, text=\")\", width=\"3\", command=onRightParen)\n  onBSpline <- function(){\n    rhs <- tclvalue(rhsVariable)\n    var <- getSelection(xBox)\n    tkselection.clear(xBox$listbox, \"0\", \"end\")\n    if (length(var) == 0) var <- \" \"\n    if (grepl(\"\\\\[factor\\\\]\", var)){\n      Message(\"spline requires a numeric variable\", type=\"error\")\n      return()\n    }\n    if (length(var) > 1){\n      Message(\"cannot select more than one variable\", type=\"error\")\n      return()\n    }\n    check <- !checkAddOperator(rhs)\n    tclvalue(rhsVariable) <- paste(rhs, \n                                   if (!check) paste(\" + bs(\", var, \", df=\", tclvalue(dfSplineVar), \")\", sep=\"\") \n                                   else paste(\" bs(\", var, \", df=\", tclvalue(dfSplineVar), \")\", sep=\"\"),\n                                   sep=\"\")\n    tkicursor(rhsEntry, \"end\")\n    tkxview.moveto(rhsEntry, \"1\")\n  }\n  onNatSline <- function(){\n    rhs <- tclvalue(rhsVariable)\n    var <- getSelection(xBox)\n    tkselection.clear(xBox$listbox, \"0\", \"end\")\n    if (length(var) == 0) var <- \" \"\n    if (grepl(\"\\\\[factor\\\\]\", var)){\n      Message(\"spline requires a numeric variable\", type=\"error\")\n      return()\n    }\n    if (length(var) > 1){\n      Message(\"cannot select more than one variable\", type=\"error\")\n      return()\n    }\n    check <- !checkAddOperator(rhs)\n    tclvalue(rhsVariable) <- paste(rhs, \n                                   if (!check) paste(\" + ns(\", var, \", df=\", tclvalue(dfSplineVar), \")\", sep=\"\") \n                                   else paste(\" ns(\", var, \", df=\", tclvalue(dfSplineVar), \")\", sep=\"\"),\n                                   sep=\"\")\n    tkicursor(rhsEntry, \"end\")\n    tkxview.moveto(rhsEntry, \"1\")\n  }\n  onPoly <- function(){\n    rhs <- tclvalue(rhsVariable)\n    var <- getSelection(xBox)\n    tkselection.clear(xBox$listbox, \"0\", \"end\")\n    if (length(var) == 0) var <- \" \"\n    if (grepl(\"\\\\[factor\\\\]\", var)){\n      Message(\"polynomial requires a numeric variable\", type=\"error\")\n      return()\n    }\n    if (length(var) > 1){\n      Message(\"cannot select more than one variable\", type=\"error\")\n      return()\n    }\n    check <- !checkAddOperator(rhs)\n    tclvalue(rhsVariable) <- paste(rhs, \n                                   if (!check) paste(\" + poly(\", var, \", degree=\", tclvalue(degPolyVar), \")\", sep=\"\") \n                                   else paste(\" poly(\", var, \", degree=\", tclvalue(degPolyVar), \")\", sep=\"\"),\n                                   sep=\"\")\n    tkicursor(rhsEntry, \"end\")\n    tkxview.moveto(rhsEntry, \"1\")\n  }\n  onRawPoly <- function(){\n    rhs <- tclvalue(rhsVariable)\n    var <- getSelection(xBox)\n    tkselection.clear(xBox$listbox, \"0\", \"end\")\n    if (length(var) == 0) var <- \" \"\n    if (grepl(\"\\\\[factor\\\\]\", var)){\n      Message(\"polynomial requires a numeric variable\", type=\"error\")\n      return()\n    }\n    if (length(var) > 1){\n      Message(\"cannot select more than one variable\", type=\"error\")\n      return()\n    }\n    check <- !checkAddOperator(rhs)\n    tclvalue(rhsVariable) <- paste(rhs, \n                                   if (!check) paste(\" + poly(\", var, \", degree=\", tclvalue(degPolyVar), \", raw=TRUE)\", sep=\"\") \n                                   else paste(\" poly(\", var, \", degree=\", tclvalue(degPolyVar), \", raw=TRUE)\", sep=\"\"),\n                                   sep=\"\")\n    tkicursor(rhsEntry, \"end\")\n    tkxview.moveto(rhsEntry, \"1\")\n  }\n  bsplineButton <- buttonRcmdr(splinePolyFrame, text=gettextRcmdr(\"B-spline\\n\"), width=\"10\", command=onBSpline)\n  nsplineButton <- buttonRcmdr(splinePolyFrame, text=gettextRcmdr(\"natural\\nspline\"), width=\"10\", command=onNatSline)\n  polyButton <- buttonRcmdr(splinePolyFrame, text=gettextRcmdr(\"orthogonal\\npolynomial\"), width=\"10\", command=onPoly)\n  RawPolyButton <- buttonRcmdr(splinePolyFrame, text=gettextRcmdr(\"raw\\npolynomial\"), width=\"10\", command=onRawPoly)\n  dfSplineVar <- tclVar(\"5\")\n  degPolyVar <- tclVar(\"2\")\n  dfDegFrame <- tkframe(outerOperatorsFrame)\n  dfSplineSpin <- tkspinbox(dfDegFrame, textvariable=dfSplineVar, state=\"readonly\", from=2, to=10, width=2)\n  degPolySpin <- tkspinbox(dfDegFrame, textvariable=degPolyVar, state=\"readonly\", from=2, to=5, width=2)\n  tkgrid(plusButton, timesButton, colonButton, slashButton, inButton, minusButton,\n         powerButton, leftParenButton, rightParenButton, sticky=\"w\")\n  tkgrid(labelRcmdr(dfDegFrame, text=gettextRcmdr(\"df for splines: \")), dfSplineSpin,  sticky=\"se\")\n  tkgrid(labelRcmdr(dfDegFrame, text=gettextRcmdr(\"deg. for polynomials: \")), degPolySpin, sticky=\"se\")\n  formulaFrame <- tkframe(frame)\n  formulaFrameMain <- tkframe(formulaFrame)\n  onFormulaHelp <- function () print(help(\"formula\"))\n  formulaHelpButton <- buttonRcmdr(formulaFrame, text=gettextRcmdr(\"Model formula\\nhelp\"), command=onFormulaHelp,\n                                   image=\"::image::helpIcon\", compound=\"left\")\n  if (hasLhs){\n    tkgrid(labelRcmdr(outerOperatorsFrame, text=gettextRcmdr(\"Model Formula\"), \n                      fg=getRcmdr(\"title.color\"), font=\"RcmdrTitleFont\"), sticky=\"w\")\n    tkgrid(labelRcmdr(outerOperatorsFrame, text=\"Operators (click to formula):  \"), operatorsFrame, sticky=\"nw\")\n    if (.rhsExtras){\n      tkgrid(bsplineButton, nsplineButton, polyButton, RawPolyButton, sticky=\"nw\")\n      tkgrid(labelRcmdr(outerOperatorsFrame, text=gettextRcmdr(\"Splines/Polynomials:\\n(select variable and click)\")), \n             splinePolyFrame, dfDegFrame, sticky=\"nw\")\n    }\n    lhsVariable <- if (currentModel) tclVar(currentFields$lhs) else tclVar(\"\")\n    rhsVariable <- if (currentModel) tclVar(currentFields$rhs) else tclVar(\"\")\n    rhsEntry <- ttkentry(formulaFrameMain, width=\"75\", textvariable=rhsVariable)\n    rhsXscroll <- ttkscrollbar(formulaFrameMain,\n                               orient=\"horizontal\", command=function(...) tkxview(rhsEntry, ...))\n    tkconfigure(rhsEntry, xscrollcommand=function(...) tkset(rhsXscroll, ...))\n    lhsEntry <- ttkentry(formulaFrameMain, width=\"10\", textvariable=lhsVariable)\n    lhsScroll <- ttkscrollbar(formulaFrameMain,\n                              orient=\"horizontal\", command=function(...) tkxview(lhsEntry, ...))\n    tkconfigure(lhsEntry, xscrollcommand=function(...) tkset(lhsScroll, ...))\n    tkgrid(lhsEntry, labelRcmdr(formulaFrameMain, text=\" ~    \"), rhsEntry, sticky=\"w\")\n    tkgrid(lhsScroll, labelRcmdr(formulaFrameMain, text=\"\"), rhsXscroll, sticky=\"w\")\n    tkgrid.configure(lhsScroll, sticky=\"ew\")\n    tkgrid(formulaFrameMain, labelRcmdr(formulaFrame, text=\"  \"), formulaHelpButton, sticky=\"nw\")\n  }\n  else{\n    if (.rhsExtras){\n      tkgrid(labelRcmdr(outerOperatorsFrame, text=formulaLabel, \n                        fg=getRcmdr(\"title.color\"), font=\"RcmdrTitleFont\"), sticky=\"w\")\n      tkgrid(labelRcmdr(outerOperatorsFrame, text=\"Operators (click to formula):  \"), operatorsFrame, sticky=\"nw\")\n      tkgrid(bsplineButton, nsplineButton, polyButton, RawPolyButton, sticky=\"nw\")\n      tkgrid(labelRcmdr(outerOperatorsFrame, text=gettextRcmdr(\"Splines/Polynomials:\\n(select variable and click)\")), \n             splinePolyFrame, dfDegFrame, sticky=\"nw\")\n    }\n    rhsVariable <- if (currentModel) tclVar(currentFields$rhs) else tclVar(\"\")\n    rhsEntry <- ttkentry(formulaFrameMain, width=\"75\", textvariable=rhsVariable)\n    rhsXscroll <- ttkscrollbar(formulaFrameMain,\n                               orient=\"horizontal\", command=function(...) tkxview(rhsEntry, ...))\n    tkconfigure(rhsEntry, xscrollcommand=function(...) tkset(rhsXscroll, ...))\n    tkgrid(labelRcmdr(formulaFrameMain, text=\"   ~ \"), rhsEntry, sticky=\"w\")\n    tkgrid(labelRcmdr(formulaFrameMain, text=\"\"), rhsXscroll, sticky=\"w\")\n    tkgrid(formulaFrameMain, labelRcmdr(formulaFrame, text=\"  \"), formulaHelpButton, sticky=\"nw\")\n  }\n  tkgrid.configure(rhsXscroll, sticky=\"ew\")\n})\n\nexists.method <- function(generic, object, default=TRUE, strict=FALSE){\n    classes <- class(object)\n    if (default) classes <- c(classes, \"default\")\n    if (strict) classes <- classes[1]\n    any(paste(generic, \".\", classes, sep=\"\") %in%\n            as.character(methods(generic)))\n}\n\ncheckMethod <- defmacro(generic, object, message=NULL, default=FALSE, strict=FALSE, reportError=TRUE,\n    expr={\n        msg <- if (is.null(message)) sprintf(gettextRcmdr(\"No appropriate %s method exists\\nfor a model of this class.\"), generic)\n        else message\n        method <- exists.method(generic, get(object), default=default, strict=strict)\n        if ((!method) && reportError) Message(message=msg, type=\"error\")\n        method\n    }\n)\n\ncheckClass <- defmacro(object, class, message=NULL,\n    expr={\n        msg <- if (is.null(message)) sprintf(gettextRcmdr('The model is not of class \"%s\".'), class)\n        else message\n        properClass <- class(get(object))[1] == class\n        if (!properClass) Message(message=msg, type=\"error\")\n        properClass\n    }\n)\n\n# the following function is from John Chambers (plus new test for R 2.4.0)\n\nisS4object <- function(object) {\n    if (getRversion() < \"2.4.0\"){\n        if (length(attr(object, \"class\"))!= 1)\n            return(FALSE)\n        !isVirtualClass(getClass(class(object), TRUE))\n    }\n    else isS4(object)\n}\n\n.RcmdrEnv <- new.env(parent=emptyenv())\n\n# putRcmdr <- function(x, value) assign(x, value, envir=.RcmdrEnv)\n# \n# getRcmdr <- function(x, mode=\"any\") get(x, envir=.RcmdrEnv, mode=mode, inherits=FALSE)\n\nRcmdrEnv <- function() .RcmdrEnv\n\nputRcmdr <- function(x, value) assign(x, value, envir=RcmdrEnv())\n\n# getRcmdr <- function(x, mode=\"any\") get(x, envir=RcmdrEnv(), mode=mode, inherits=FALSE)\n\ngetRcmdr <- function(x, mode=\"any\", fail=TRUE){\n    if ((!fail) && (!exists(x, mode=mode, envir=RcmdrEnv(), inherits=FALSE))) return(NULL)\n    get(x, envir=RcmdrEnv(), mode=mode, inherits=FALSE)\n}\n\n\nRcmdrTclSet <- function(name, value){\n    name <- ls(unclass(getRcmdr(name))$env)\n    tcl(\"set\", name, value)\n}\n\n# functions to store or retrieve Rcmdr state information\n\nVariables <- function(names){\n    if (missing(names)) getRcmdr(\"variables\")\n    else putRcmdr(\"variables\", names)\n}\n\nNumeric <- function(names){\n    if (missing(names)) getRcmdr(\"numeric\")\n    else putRcmdr(\"numeric\", names)\n}\n\nFactors <- function(names){\n    if (missing(names)) getRcmdr(\"factors\")\n    else putRcmdr(\"factors\", names)\n}\n\nTwoLevelFactors <- function(names){\n    if (missing(names)) getRcmdr(\"twoLevelFactors\")\n    else putRcmdr(\"twoLevelFactors\", names)\n}\n\n# The following two functions were modified by Erich Neuwrith\n#  and subsequently by John Fox (23 July 07)\n#  and Milan Bouchet-Valat (27 March 14)\n\nActiveDataSet <- function(name){\n    if (missing(name)) {\n        temp <- getRcmdr(\".activeDataSet\")\n        if (is.null(temp))\n            return(NULL)\n        else\n            if (!exists(temp) || !is.data.frame(get(temp,envir=.GlobalEnv))) {\n                Message(sprintf(gettextRcmdr(\"the dataset %s is no longer available\"),\n                    temp), type=\"error\")\n                putRcmdr(\".activeDataSet\", NULL)\n                Variables(NULL)\n                Numeric(NULL)\n                Factors(NULL)\n                TwoLevelFactors(NULL)\n                RcmdrTclSet(\"dataSetName\", gettextRcmdr(\"<No active dataset>\"))\n                putRcmdr(\".activeModel\", NULL)\n                putRcmdr(\"nrow\", NULL)\n                putRcmdr(\"ncol\", NULL)\n                RcmdrTclSet(\"modelName\", gettextRcmdr(\"<No active model>\"))\n                tkconfigure(getRcmdr(\"dataSetLabel\"), foreground=\"red\") \n                tkconfigure(getRcmdr(\"modelLabel\"), foreground=\"red\") \n                activateMenus()\n                if (getRcmdr(\"suppress.menus\") && RExcelSupported()) return(NULL)\n            }\n        return(temp)\n    }\n    else {\n        putRcmdr(\".activeDataSet\", name)\n\n      if(!is.null(name)) {\n        Variables(listVariables(name))\n        Numeric(listNumeric(name))\n        Factors(listFactors(name))\n        TwoLevelFactors(listTwoLevelFactors(name))\n        open.showData.windows <- getRcmdr(\"open.showData.windows\")\n        if (!is.null(open.showData.windows) && name %in% names(open.showData.windows)){\n          ID <- open.showData.windows[[name]]$ID\n          posn <- as.numeric(c(tclvalue(.Tcl(paste(\"winfo x\", ID))),\n                       tclvalue(.Tcl(paste(\"winfo y\", ID)))))\n          posn <- paste(\"+\", paste(posn, collapse = \"+\"), sep = \"\")\n          tkdestroy(open.showData.windows[[name]])\n          suppress <- if(getRcmdr(\"suppress.X11.warnings\")) \", suppress.X11.warnings=FALSE\" else \"\"\n          view.height <- max(as.numeric(getRcmdr(\"output.height\")) + as.numeric(getRcmdr(\"log.height\")), 10)\n          command <- paste(\"showData(\", name, \", placement='\", posn, \"', font=getRcmdr('logFont'), maxwidth=\",\n                           getRcmdr(\"log.width\"), \", maxheight=\", view.height, suppress, \")\", sep=\"\")\n          window <- justDoIt(command)\n          open.showData.windows[[ActiveDataSet()]] <- window\n          putRcmdr(\"open.showData.windows\", open.showData.windows)\n        }\n        \n      }\n        else {\n            Variables(NULL)\n            Numeric(NULL)\n            Factors(NULL)\n            TwoLevelFactors(NULL)\n            RcmdrTclSet(\"dataSetName\", gettextRcmdr(\"<No active dataset>\"))\n            putRcmdr(\".activeModel\", NULL)\n            putRcmdr(\"nrow\", NULL)\n            putRcmdr(\"ncol\", NULL)\n            RcmdrTclSet(\"modelName\", gettextRcmdr(\"<No active model>\"))\n            tkconfigure(getRcmdr(\"dataSetLabel\"), foreground=\"red\") \n            tkconfigure(getRcmdr(\"modelLabel\"), foreground=\"red\") \n            activateMenus()\n            if (getRcmdr(\"suppress.menus\") && RExcelSupported()) return(NULL)\n        }\n    }\n}\n\nActiveModel <- function(name){\n    if (missing(name)) {\n        temp <- getRcmdr(\".activeModel\")\n        if (is.null(temp))\n            return(NULL)\n        else\n            if (!exists(temp) || !is.model(get(temp,envir=.GlobalEnv))) {\n                Message(sprintf(gettextRcmdr(\"the model %s is no longer available\"),\n                    temp), type=\"error\")\n                putRcmdr(\".activeModel\", NULL)\n                RcmdrTclSet(\"modelName\", gettextRcmdr(\"<No active model>\"))\n                tkconfigure(getRcmdr(\"modelLabel\"), foreground=\"red\")\n                activateMenus()\n                return(NULL)\n            }\n        else return(temp)\n    }\n    else putRcmdr(\".activeModel\", name)\n}\n\nGrabFocus <- function(value){\n    if (missing(value)) getRcmdr(\"grab.focus\")\n    else putRcmdr(\"grab.focus\", value)\n}\n\nUpdateModelNumber <- function(increment=1){\n    modelNumber <- getRcmdr(\"modelNumber\")\n    modelNumber <- modelNumber + increment\n    if (modelNumber < 1) modelNumber <- 1 # sanity check\n    putRcmdr(\"modelNumber\", modelNumber)\n}\n\nCommanderWindow <- function() getRcmdr(\"commanderWindow\")\n\nLogWindow <- function() getRcmdr(\"logWindow\")\n\nRmdWindow <- function() getRcmdr(\"RmdWindow\")\n\nRnwWindow <- function() getRcmdr(\"RnwWindow\")\n\nOutputWindow <- function() getRcmdr(\"outputWindow\")\n\nMessagesWindow <- function() getRcmdr(\"messagesWindow\")\n\n# some predicates for the menu system\n\nactiveDataSetP <- function() !is.null(ActiveDataSet())\n\ndataSetsP <- function(n=1){\n    datasets <- listDataSets()\n    (!is.null(datasets)) && length(datasets) >= n\n}\n\nnumericP <- function(n=1) activeDataSetP() && length(listNumeric()) >= n\n\nfactorsP <- function(n=1) activeDataSetP() && length(listFactors()) >= n\n\ntwoLevelFactorsP <- function(n=1) activeDataSetP() && length(listTwoLevelFactors()) >= n\n\nmodelsP <- function(n=1) activeDataSetP() && length(listAllModels()) >= n\n\nactiveModelP <- function() !is.null(ActiveModel())\n\nlmP <- function() activeModelP() && any(class(get(ActiveModel()))[1] == c('lm', 'aov'))\n\nglmP <- function() activeModelP() && class(get(ActiveModel()))[1] == 'glm'\n\naicP <- function() activeModelP() && exists.method(\"extractAIC\", get(ActiveModel()))\n\npolrP <- function() activeModelP() && class(get(ActiveModel()))[1] == 'polr'\n\nmultinomP <- function() activeModelP() && class(get(ActiveModel()))[1] == 'multinom'\n\nhclustSolutionsP <- function() length(listHclustSolutions()) > 0\n\nMacOSXP <- function(release) {\n    sys <- Sys.info()\n    OSX <- !is.null(sys) && length(grep(\"[Dd]arwin\", sys[\"sysname\"]) > 0)\n    if (missing(release)) OSX\n    else (OSX && release <= sys[\"release\"])\n}\n\npackageAvailable <- function(name) 0 != length(find.package(name, quiet=TRUE))\n\nrglLoaded <- function() 0 != length(grep(\"^rgl\", loadedNamespaces()))\n\nactivateMenus <- function(){\n    if (getRcmdr(\"suppress.menus\")) return()\n    for (item in getRcmdr(\"Menus\")){\n        if (item$activation()) .Tcl(paste(item$ID, \" entryconfigure \", item$position - 1,\" -state normal\", sep=\"\"))\n        else .Tcl(paste(item$ID, \" entryconfigure \", item$position - 1,\" -state disabled\", sep=\"\"))\n    }\n}\n\n# for internationalization\n\ngettextRcmdr <- function(...) gettext(..., domain=\"R-Rcmdr\")\n\ngettextMenus <- function(...){\n    text <- gettextRcmdr(...)\n    plugins <- getOption(\"Rcmdr\")$plugins\n    if (is.null(plugins)) return(text)\n    plugins <- paste(\"R-\", plugins, sep=\"\")\n    for (plugin in plugins){\n        text <- gettext(text, domain=plugin)\n    }\n    text\n}\n\nEnglish <- function() {\n    env <- Sys.getenv()\n    names(env) <- toupper(names(env))\n    LANG <- env[\"LANGUAGE\"]\n    LC_CTYPE <- Sys.getlocale(\"LC_CTYPE\")\n    if (!is.na(LANG)) length(grep(\"^en\", LANG, ignore.case=TRUE)) > 0\n    else LC_CTYPE == \"C\" || length(grep(\"^en\", LC_CTYPE, ignore.case=TRUE)) > 0\n}\n\n# to replace tkmessageBox on non-English Windows systems,\n#  to allow for translation of button text\n\nRcmdrTkmessageBox <- function(message, icon=c(\"info\", \"question\", \"warning\",\n    \"error\"), type=c(\"okcancel\", \"yesno\", \"ok\"), default, title=\"\") {\n    if ( (English()) || (!WindowsP()) ){\n        if (missing(default)){\n            default <- switch(type,\n                okcancel=\"ok\",\n                yesno=\"yes\",\n                ok=\"ok\")}\n        return(tkmessageBox(message=message, icon=icon, type=type,\n            default=default, title=title))\n    }\n    icon <- match.arg(icon)\n    type <- match.arg(type)\n    initializeDialog(messageBox, title=title)\n    messageFrame <- tkframe(messageBox, borderwidth=5)\n    buttonFrame <- tkframe(messageBox,  borderwidth=5)\n    if (icon != \"question\") tkbell()\n    result <- tclVar()\n    iconColor <- switch(icon, info=getRcmdr(\"title.color\"), question=getRcmdr(\"title.color\"), warning=\"black\",\n        error=\"red\")\n    onOK <- function() {\n        if (GrabFocus()) tkgrab.release(messageBox)\n        tkdestroy(messageBox)\n        tkfocus(CommanderWindow())\n        tclvalue(result) <- \"ok\"\n    }\n    OKbutton <- buttonRcmdr(buttonFrame, text=gettextRcmdr(\"OK\"),\n        foreground=\"darkgreen\", width=\"12\", command=onOK, borderwidth=3,\n        default=if (missing(default)) \"active\"\n        else if (default == \"ok\") \"active\" else \"normal\")\n    onCancel <- function() {\n        if (GrabFocus()) tkgrab.release(messageBox)\n        tkdestroy(messageBox)\n        tkfocus(CommanderWindow())\n        tclvalue(result) <- \"cancel\"\n    }\n    cancelButton <- buttonRcmdr(buttonFrame, text=gettextRcmdr(\"Cancel\"),\n        foreground=\"red\", width=\"12\", command=onCancel, borderwidth=3,\n        default=if (missing(default)) \"normal\"\n        else if (default == \"cancel\") \"active\" else \"normal\")\n    onYes <- function() {\n        if (GrabFocus()) tkgrab.release(messageBox)\n        tkdestroy(messageBox)\n        tkfocus(CommanderWindow())\n        tclvalue(result) <- \"yes\"\n    }\n    yesButton <- buttonRcmdr(buttonFrame, text=gettextRcmdr(\"Yes\"),\n        foreground=\"darkgreen\", width=\"12\", command=onYes, borderwidth=3,\n        default=if (missing(default)) \"active\"\n        else if (default == \"yes\") \"active\" else \"normal\")\n    onNo <- function() {\n        if (GrabFocus()) tkgrab.release(messageBox)\n        tkdestroy(messageBox)\n        tkfocus(CommanderWindow())\n        tclvalue(result) <- \"no\"\n    }\n    noButton <- buttonRcmdr(buttonFrame, text=gettextRcmdr(\"No\"),\n        foreground=\"red\", width=\"12\", command=onNo, borderwidth=3,\n        default=if (missing(default)) \"normal\"\n        else if (default == \"no\") \"active\" else \"normal\")\n    ## FIXME -- left in old style\n    tkgrid(tklabel(messageFrame, bitmap=icon, fg=iconColor),\n        tklabel(messageFrame, text=\"    \"),\n        tklabel(messageFrame, text=message))\n    tkgrid(messageFrame)\n    switch(type,\n        okcancel = {\n            tkgrid(OKbutton, labelRcmdr(buttonFrame, text=\"    \"), cancelButton)\n            if (missing(default) || default == \"ok\") tkbind(messageBox, \"<Return>\",\n                onOK)\n            else if (default == \"cancel\") tkbind(messageBox, \"<Return>\", onCancel)\n        },\n        yesno =  {\n            tkgrid(yesButton, labelRcmdr(buttonFrame, text=\"    \"), noButton)\n            if (missing(default) || default == \"yes\") tkbind(messageBox, \"<Return>\",\n                onYes)\n            else if (default == \"no\") tkbind(messageBox, \"<Return>\", onNo)\n        },\n        ok = {\n            tkgrid(OKbutton)\n            if (missing(default) || default == \"ok\") tkbind(messageBox, \"<Return>\",\n                onOK)\n        }\n    )\n    tkgrid(buttonFrame)\n    dialogSuffix(messageBox, focus=messageBox, bindReturn=FALSE, force.wait=TRUE)\n    result\n}\n\n# The following function was contributed by Matthieu Lesnoff (added 20 July 06)\n\ntrim.col.na <- function(dat){\n    # Remove variables with only missing values (occurs sometimes with modified Excel file)\n    colsup <- NULL\n    for (i in 1:ncol(dat))\n    {\n        if (length(dat[is.na(dat[,i])==T,i]) ==length(dat[,i]))\n            colsup <- c(colsup,i)\n    }\n    if (length(colsup) > 0)\n        dat <- dat[,-colsup]\n    dat\n}\n\n# check whether packages are available\n\npackagesAvailable <- function(packages){\n    sapply(sapply(packages, find.package, quiet=TRUE),\n        function(x) length(x) != 0)\n}\n\n# insert a row (or rows) in a matrix or data frame\n\ninsertRows <- function(object1, object2, where=NULL, ...){\n    if (ncol(object1) != ncol(object2))\n        stop(gettextRcmdr(\"objects have different numbers of columns\"))\n    if (!(TRUE == all.equal(colnames(object1), colnames(object2))))\n        stop(gettextRcmdr(\"objects have different column names\"))\n    n <- nrow(object1)\n    if (is.null(where) || where >= n) rbind(object1, object2)\n    else if (where < 1) rbind(object2, object1)\n    else rbind(object1[1:floor(where),], object2,\n        object1[(floor(where) + 1):n,])\n}\n\n# functions for handling Rcmdr plug-in packages\n\n# the following function based on a suggestion by Brian Ripley\n\nlistPlugins <- function(loaded=FALSE){\n    plugins <- unlist(lapply(.libPaths(),\n        function(x) Sys.glob(file.path(x, \"*/etc/menus.txt\"))))\n    plugins <- sub(\".*/([^/]*)/etc/menus.txt\", \"\\\\1\", plugins)\n    if (loaded) plugins else sort(setdiff(plugins, .packages()))\n}\n\n\nloadPlugins <- function(){\n    plugins <- listPlugins()\n    initializeDialog(title=gettextRcmdr(\"Load Plug-ins\"))\n    packagesBox <- variableListBox(top, plugins, title=gettextRcmdr(\"Plug-ins (pick one or more)\"),\n        selectmode=\"multiple\", listHeight=10)\n    onOK <- function(){\n        plugins <- getSelection(packagesBox)\n        closeDialog(top)\n        if (length(plugins) == 0){\n            errorCondition(recall=loadPlugins, message=gettextRcmdr(\"You must select at least one plug-in.\"))\n            return()\n        }\n        opts <- options(\"Rcmdr\")\n        opts$Rcmdr$plugins <- c(plugins, opts$Rcmdr$plugins)\n        options(opts)\n        for (plugin in plugins) {\n            command <- paste('library(\"', plugin, '\", character.only=TRUE)', sep=\"\")\n            justDoIt(command)\n        }\n        Message(paste(gettextRcmdr(\"Plug-ins loaded:\"), paste(plugins, collapse=\", \")), type=\"note\")\n        response <- tkmessageBox(message=paste(gettextRcmdr(\n            \"The plug-in(s) will not be available until the Commander is restarted.\\nRestart now?\")),\n            icon=\"question\", type=\"yesno\")\n        if (tclvalue(response) == \"yes\") {\n            putRcmdr(\"autoRestart\", TRUE)\n            closeCommander(ask=FALSE)\n            Commander()\n        }\n    }\n    OKCancelHelp(helpSubject=\"Plugins\")\n    tkgrid(getFrame(packagesBox), sticky=\"nw\")\n    tkgrid(buttonsFrame, sticky=\"w\")\n    dialogSuffix()\n}\n\n# the following two functions contributed by Erich Neuwirth (added 22 July 07)\n\nwhitespaceonly <- function(str) sub('[[:space:]]+$', '', str) == ''\n\nis.model <- function(object) {\n    any(class(object) %in% getRcmdr(\"modelClasses\"))\n}\n\n# the following lines, adding support for ttk widgets, adapted from code by Brian Ripley\nif (!(as.character(tcl(\"info\", \"tclversion\")) >= \"8.5\" && getRversion() >= \"2.7.0\")){\n    buttonRcmdr <- tkbutton\n    labelRcmdr <- tklabel\n    ttkentry <- function(parent, ...) tkentry(parent, ...)\n    ttkframe <- tkframe\n    ttkradiobutton <- tkradiobutton\n    ttkscrollbar <- function(...) tkscrollbar(..., repeatinterval=5)\n} else {\n    buttonRcmdr <- function(..., borderwidth, fg, foreground, relief) ttkbutton(...)\n    labelRcmdr <- function(..., fg)\n        if(missing(fg)) ttklabel(...) else ttklabel(..., foreground=fg)\n}\n\n# Label looking like that of a TtkLabelFrame\ntitleLabel <- function(...) labelRcmdr(..., font=\"RcmdrTitleFont\", fg=getRcmdr(\"title.color\"))\n\n# the following function alters the default behaviour of tclvalue() by trimming leading and trailing blanks\n\ntclvalue <- function(x) trim.blanks(tcltk::tclvalue(x))\n\n# the following function splits a character string at blanks and commas according to width\n\nsplitCmd <- function(cmd, width=getOption(\"width\") - 4, at=\"[ ,]\"){\n  if (length(grep(\"\\n\", cmd)) >0 ){\n    cmds <- strsplit(cmd, \"\\n\")[[1]]\n    allcmds <- character(length(cmds))\n    for (i in 1:length(cmds))\n      allcmds[i] <- splitCmd(cmds[i], width=width, at=at)\n    return(paste(allcmds, collapse=\"\\n\"))\n  }\n  if (nchar(cmd) <= width) return(cmd)\n  where <- gregexpr(at, cmd)[[1]]\n  if (where[1] < 0) return(cmd)\n  singleQuotes <- gregexpr(\"'\", cmd)[[1]]\n  doubleQuotes <- gregexpr('\"', cmd)[[1]]\n  comment <- regexpr(\"#\", cmd)\n  if (singleQuotes[1] > 0 && (singleQuotes[1] < doubleQuotes[1] || doubleQuotes[1] < 0 ) && (singleQuotes[1] < comment[1] || comment[1] < 0 )){\n    nquotes <- length(singleQuotes)\n    if (nquotes < 2) stop(\"unbalanced quotes\")\n    for(i in seq(nquotes/2))\n      where[(where > singleQuotes[2 * i - 1]) & (where < singleQuotes[2 * i])] <- NA\n    where <- na.omit(where)\n  }  \n  else if (doubleQuotes[1] > 0 && (doubleQuotes[1] < singleQuotes[1] || singleQuotes[1] < 0) && (doubleQuotes[1] < comment[1] || comment[1] < 0 )){\n    nquotes <- length(doubleQuotes)\n    if (nquotes < 2) stop(\"unbalanced quotes\")\n    for(i in seq(nquotes/2))\n      where[(where > doubleQuotes[2 * i - 1]) & (where < doubleQuotes[2 * i])] <- NA\n    where <- na.omit(where)\n  }\n  else if (comment > 0){\n    where[where > comment] <- NA\n    where <- na.omit(where)\n  }\n  if (length(where) == 0) return(cmd)\n  where2 <- where[where <= width]\n  where2 <- if (length(where2) == 0) where[1]\n  else where2[length(where2)]\n  paste(substr(cmd, 1, where2), \"\\n  \", \n        Recall(substr(cmd, where2 + 1, nchar(cmd)), width, at), sep=\"\")\n} \n\n# the following function sorts names containing numerals \"more naturally\" than does sort()\n\nsortVarNames <- function(x){\n    sort.helper <- function(x){\n        prefix <- strsplit(x, \"[0-9]+\")\n        prefix <- sapply(prefix, \"[\", 1)\n        prefix[is.na(prefix)] <- \"\"\n        suffix <- strsplit(x, \"[^0-9]+\")\n        suffix <- as.numeric(sapply(suffix, \"[\", 2))\n        suffix[is.na(suffix)] <- -Inf\n        remainder <- sub(\"[^0-9]+\", \"\", x)\n        remainder <- sub(\"[0-9]+\", \"\", remainder)\n        if (all (remainder == \"\")) list(prefix, suffix)\n        else c(list(prefix, suffix), Recall(remainder))\n    }\n    ord <- do.call(\"order\", sort.helper(x))\n    x[ord]\n}\n\n# to load packages\n\nLibrary <- function(package, pos=length(search()), rmd=TRUE){\n    dependencies <- tools::package_dependencies(package, db=getRcmdr(\"installed.packages\"), which=\"Depends\")\n    loaded <- search()\n    loaded <- loaded[grep(\"^package:\", loaded)]\n    loaded <- sub(\"^package:\", \"\", loaded)\n    if (!getRcmdr(\"suppress.X11.warnings\")){\n        messages.connection <- file(open=\"w+\")\n        sink(messages.connection, type=\"message\")\n        on.exit({\n            sink(type=\"message\")\n            close(messages.connection)\n        })\n    }\n    if (!(package %in% loaded)){\n        for (pkg in dependencies[[package]]){\n            Library(pkg, pos=pos, rmd=rmd)\n        }\n        command <- paste(\"library(\", package, \", pos=\", pos, \")\", sep=\"\")\n        logger(command, rmd=rmd)\n        result <- try(eval(parse(text=command), envir=.GlobalEnv), silent=TRUE)\n        if (class(result)[1] ==  \"try-error\"){\n            Message(message=paste(strsplit(result, \":\")[[1]][2]), type=\"error\")\n            tkfocus(CommanderWindow())\n            return(\"error\")\n        }\n        return(package)\n    }\n    else return(invisible(NULL))\n}\n\n# Library <- function(package, pos=4, rmd=TRUE){\n#     loaded <- search()\n#     loaded <- loaded[grep(\"^package:\", loaded)]\n#     loaded <- sub(\"^package:\", \"\", loaded)\n#     if (!getRcmdr(\"suppress.X11.warnings\")){\n#         messages.connection <- file(open=\"w+\")\n#         sink(messages.connection, type=\"message\")\n#         on.exit({\n#             sink(type=\"message\")\n#             close(messages.connection)\n#         })\n#     }\n#     if (!(package %in% loaded)){\n#         command <- paste(\"library(\", package, \", pos=\", pos, \")\", sep=\"\")\n#         logger(command, rmd=rmd)\n#         result <- try(eval(parse(text=command), envir=.GlobalEnv), silent=TRUE)\n#         if (class(result)[1] ==  \"try-error\"){\n#             Message(message=paste(strsplit(result, \":\")[[1]][2]), type=\"error\")\n#             tkfocus(CommanderWindow())\n#             return(\"error\")\n#         }\n#         return(package)\n#     }\n#     else return(invisible(NULL))\n# }\n\n# start help system\n\nstartHelp <- function(){\n    Sys.sleep(2)\n    help.start()\n}\n\n# dialog memory support\n\nputDialog <- function (dialog, values=NULL, resettable=TRUE){\n    if (resettable){\n        dialog.values <- getRcmdr(\"dialog.values\")\n        dialog.values[[dialog]] <- values\n        putRcmdr(\"dialog.values\", dialog.values)\n    }\n    else{\n        dialog.values <- getRcmdr(\"dialog.values.noreset\")\n        dialog.values[[dialog]] <- values\n        putRcmdr(\"dialog.values.noreset\", dialog.values)\n    }\n}\n\ngetDialog <- function(dialog, defaults=NULL){\n    values <- getRcmdr(\"dialog.values.noreset\")[[dialog]]\n    if (getRcmdr(\"retain.selections\") && !is.null(values)) return(values)\n    values <- getRcmdr(\"dialog.values\")[[dialog]]\n    if (!getRcmdr(\"retain.selections\") || is.null(values)) return(defaults)\n    else return (values)\n}\n\nvarPosn <- function(variables, \n    type=c(\"all\", \"factor\", \"numeric\", \"nonfactor\", \"twoLevelFactor\"), vars=NULL){\n    if (is.null(variables)) return(NULL)\n    type <- match.arg(type)\n    if (is.null(vars)) vars <- switch(type,\n        all = Variables(),\n        factor = Factors(),\n        numeric = Numeric(),\n        nonfactor = setdiff(Variables(), Factors()),\n        twoLevelFactor = TwoLevelFactors()\n    )\n    if (any(!variables %in% vars)) NULL\n    else apply(outer(variables, vars, \"==\"), 1, which) - 1\n}\n\nflushDialogMemory <- function(what){\n    if (missing(what)) putRcmdr(\"dialog.values\", list())\n    else{\n        dialog.values <- getRcmdr(\"dialog.values\")\n        dialog.values.noreset <- getRcmdr(\"dialog.values.noreset\")\n        for (dialog in what){\n            dialog.values[dialog] <- NULL\n            dialog.values.noreset[dialog] <- NULL\n        }\n        putRcmdr(\"dialog.values\", dialog.values)\n        putRcmdr(\"dialog.values.noreset\", dialog.values.noreset)\n    }\n}\n\n# for assignments to the global environment\n\ngassign <- function(x, value){\n    if (!(is.valid.name(x))) stop(\"argument x not a valid R name\")\n    G <- .GlobalEnv\n    assign(x, value, envir=G)\n}\n\n\ntkfocus <- function(...) tcl(\"focus\", ...)\n\ntkspinbox <- function(parent, ...) tkwidget(parent, \"spinbox\", ...)\n\n# the following two functions adapted from Milan Bouchet-Valat\n\nWindowsP <- function() {\n    .Platform$OS.type == \"windows\"\n}\n\nX11P <- function(){\n    .Platform$GUI == \"X11\"\n}\n\n# the following functions to support R Markdown\n\ntrimTrailingNewLines <- function(string){\n  repeat{\n    where <- regexpr(\"\\n\\n[ ]*$\", string)\n    if (where == -1) break\n    string <- paste0(substr(string, 1, where - 1), substr(string, where + 2, nchar(string)))\n  }\n  paste0(string, \"\\n\")\n}\n\nsuppressMarkdown <- function(command){\n    attr(command, \"suppressRmd\") <- TRUE\n    command\n}\n\nbeginRmdBlock <- function(){\n    .rmd <- RmdWindow()\n    last2 <- tclvalue(tkget(.rmd, \"end -2 chars\", \"end\"))\n    if (last2 != \"\\n\\n\") tkinsert(.rmd, \"end\", \"\\n\")\n    tkinsert(.rmd, \"end\", \"\\n\")\n    if (getRcmdr(\"rgl.command\") && getRcmdr(\"use.rgl\")) tkinsert(.rmd, \"end\", \"```{r, webgl=TRUE}\\n\")\n      else tkinsert(.rmd, \"end\", \"```{r}\\n\")\n}\n\nendRmdBlock <- function(){\n    .rmd <- RmdWindow()\n    rmd <- tclvalue(tkget(.rmd, \"1.0\", \"end\"))\n    rmd <- paste(substring(rmd, 1, nchar(rmd) - 1), \"```\\n\", sep=\"\")\n    rmd <- trimHangingEndRmdBlock(rmd)\n    rmd <- trimTrailingNewLines(rmd)\n    tkdelete(.rmd, \"1.0\", \"end\")\n    tkinsert(.rmd, \"end\", rmd)\n    tkyview.moveto(.rmd, 1)\n}\n\nremoveNullRmdBlocks <- function(){\n    .rmd <- RmdWindow()\n    rmd <- tclvalue(tkget(.rmd, \"1.0\", \"end\"))\n    rmd <- gsub(\"\\n+$\", \"\\n\", rmd)\n    rmd <- gsub(\"```\\\\{r\\\\}\\n$\", \"\", rmd)\n    rmd <- gsub(\"```\\\\{r\\\\}\\n```\\n$\", \"\", rmd)\n    tkdelete(.rmd, \"1.0\", \"end\")\n    tkinsert(.rmd, \"end\", rmd)\n    tkyview.moveto(.rmd, 1)\n}\n\nremoveStrayRmdBlocks <- function(){\n    .rmd <- RmdWindow()\n    rmd <- tclvalue(tkget(.rmd, \"1.0\", \"end\"))\n    rmd <- strsplit(rmd, \"\\\\n\")[[1]]\n    starts <- grep(\"^```\\\\{r.*\\\\}$\", rmd)\n    ends  <- grep(\"^```$\", rmd)\n    n.ends <- length(ends)\n    j <- 1\n    if (length(starts) > 1){\n        for (i in 1:(length(starts) - 1)){\n            if (j > n.ends || ends[j] > starts[i + 1]) {\n                rmd[starts[i]] <- \"\"\n            }\n            else {\n                j <- j + 1\n                next\n            }\n        }\n    }\n    else return()\n    rmd <- paste(rmd, collapse=\"\\n\")\n    tkdelete(.rmd, \"1.0\", \"end\")\n    tkinsert(.rmd, \"end\", rmd)\n    tkyview.moveto(.rmd, 1)\n}\n\nenterMarkdown <- function(command){\n    if (!getRcmdr(\"use.markdown\")) return()\n    .rmd <- RmdWindow()\n    command <- splitCmd(command)\n    beginRmdBlock()\n    tkinsert(.rmd, \"end\", paste(command, \"\\n\", sep=\"\"))\n    tkyview.moveto(.rmd, 1)\n    putRcmdr(\"markdown.output\", TRUE)\n    endRmdBlock()\n    command\n}\n\ntrimHangingEndRmdBlock <- function(string){\n    loc.ends <- gregexpr(\"```\\n\", string)[[1]]\n    n.ends <- length(loc.ends)\n    if (n.ends > 1){\n        substr <- substring(string, loc.ends[n.ends - 1], loc.ends[n.ends])\n        if (!grepl(\"```\\\\{r\\\\}|```\\\\{r, webgl=TRUE\\\\}\", substr)){\n            string <- cutstring(string, loc.ends[n.ends], loc.ends[n.ends] + 3)\n        }\n    }\n    string\n}\n\nremoveLastRmdBlock <- function(){\n    .rmd <- RmdWindow()    \n    rmd <- tclvalue(tkget(.rmd, \"1.0\", \"end\"))\n    start <- gregexpr(\"```\\\\{r\\\\}\\n|```\\\\{r, webgl=TRUE\\\\}\\n\", rmd)\n    if (start[[1]][1] > 0){\n        start <- start[[1]]\n        start <- start[length(start)]\n        tail <- substring(rmd, start, nchar(rmd))\n        end <- gregexpr(\"```\\n\", tail)\n        end <- if (end[[1]][1] > 0) end[[1]][1] + 3 else nchar(tail)\n        rmd <- cutstring(rmd, start, start + end)\n        rmd <- trimTrailingNewLines(rmd)\n        tkdelete(.rmd, \"1.0\", \"end\")\n        tkinsert(.rmd, \"end\", rmd)\n        tkyview.moveto(.rmd, 1)\n    }\n}\n\nremoveRglRmdBlocks <- function(string){\n  repeat{\n    match <- regexpr(\"```\\\\{r, webgl=TRUE\\\\}\\n\", string)\n    if (match == -1) return(trimTrailingNewLines(string))\n    substring <- cutstring(string, end=match)\n    match.end <- regexpr(\"```\\n\", substring)\n    string <- cutstring(string, match, match + match.end + 3)\n  }\n}\n\ncutstring <- function(x, start=1, end=nchar(x)){\n    one <- if (start > 1) substr(x, 1, start - 1) else \"\"\n    two <- if (end < nchar(x)) substr(x, end + 1, nchar(x)) else \"\"\n    paste0(one, two)\n}\n\nMarkdownP <- function(){\n    getRcmdr(\"log.commands\") && getRcmdr(\"use.markdown\")\n}\n\ncompileRmd <- function() {\n    ChooseOutputFormat <- function(){\n        initializeDialog(title=gettextRcmdr(\"Select Output Format\"))\n        format <- getRcmdr(\"rmd.output.format\")\n        putRcmdr(\"abort.compile.rmd\", TRUE)\n        hasLatex <- getRcmdr(\"capabilities\")$pdflatex\n        radioButtons(name=\"formatButtons\", \n            buttons=c(\"html\", if (hasLatex) \"pdf\", \"docx\", \"rtf\"), \n            initialValue=format,\n            labels=c(gettextRcmdr(\".html (web page)\"), \n                if (hasLatex) gettextRcmdr(\".pdf (PDF file)\"), gettextRcmdr(\".docx (Word file)\"), gettextRcmdr(\".rtf (rich text file)\")))\n        onOK <- function(){\n            putRcmdr(\"abort.compile.rmd\", FALSE)\n            format <- tclvalue(formatButtonsVariable)\n            putRcmdr(\"rmd.output.format\", format)\n            closeDialog()\n        }\n        OKCancelHelp()\n        tkgrid(formatButtonsFrame, sticky=\"w\")\n        dialogSuffix(force.wait=TRUE, grid.buttons=TRUE)\n    }\n    .RmdFile <- getRcmdr(\"RmdFileName\")\n    rmdDir <- dirname(.RmdFile)\n    saveDir <- setwd(rmdDir)\n    on.exit(setwd(saveDir))\n    fig.files <- list.files(\"./figure\")\n    fig.files <- fig.files[grep(\"^unnamed-chunk-[0-9]*\\\\..*$\", fig.files)]\n    if (length(fig.files) != 0) {\n        response <- tkmessageBox(message = gettextRcmdr(\"Delete previously created R Markdown\\ngraphics files (recommended)?\"),\n            icon = \"question\", type = \"okcancel\", default = \"ok\")\n        if (tclvalue(response) == \"ok\") unlink(paste(\"./figure/\", fig.files, sep=\"\"))\n    }\n    removeStrayRmdBlocks()\n    lines <- tclvalue(tkget(RmdWindow(), \"1.0\", \"end\"))\n    lines <- sub(\"date: \\\"AUTOMATIC\\\"\", paste(\"date: \\\"\", as.character(Sys.time()), \"\\\"\", sep=\"\"), lines)\n    .filename <- sub(\"\\\\.Rmd$\", \"\", trim.blanks(.RmdFile))\n    writeLines(lines, .RmdFile)\n    if (getRcmdr(\"capabilities\")$pandoc){\n        ChooseOutputFormat()\n        if (getRcmdr(\"abort.compile.rmd\")){\n            putRcmdr(\"abort.compile.rmd\", NULL)\n            return()\n        }\n        else putRcmdr(\"abort.compile.rmd\", NULL)\n        format <- getRcmdr(\"rmd.output.format\")\n        switch(format,\n            html = {\n                rmarkdown::render(.RmdFile, rmarkdown::html_document())\n                .html.file <- paste(.filename, \".html\", sep=\"\")\n                .html.file.location <- paste(\"file:///\", normalizePath(.html.file), sep=\"\")\n                Message(paste(gettextRcmdr(\"HTML file written to:\"), normalizePath(.html.file)), type=\"note\")\n                browseURL(.html.file.location)\n            },\n            pdf = {\n                lines <- removeRglRmdBlocks(lines)\n                writeLines(lines, .RmdFile)\n                rmarkdown::render(.RmdFile, rmarkdown::pdf_document())\n                .pdf.file <- paste(.filename, \".pdf\", sep=\"\")\n                .pdf.file.location <- paste(\"file:///\", normalizePath(.pdf.file), sep=\"\")\n                Message(paste(gettextRcmdr(\"PDF file written to:\"), normalizePath(.pdf.file)), type=\"note\")\n                browseURL(.pdf.file.location)\n            },\n            docx = {\n              lines <- removeRglRmdBlocks(lines)\n              writeLines(lines, .RmdFile)\n                rmarkdown::render(.RmdFile, rmarkdown::word_document())\n                .docx.file <- paste(.filename, \".docx\", sep=\"\")\n                Message(paste(gettextRcmdr(\"Word file written to:\"), normalizePath(.docx.file)), type=\"note\")\n            },\n            rtf = {\n              lines <- removeRglRmdBlocks(lines)\n              writeLines(lines, .RmdFile)\n              rmarkdown::render(.RmdFile, rmarkdown::rtf_document())\n              .rtf.file <- paste(.filename, \".rtf\", sep=\"\")\n              Message(paste(gettextRcmdr(\"Rich text file written to:\"), normalizePath(.rtf.file)), type=\"note\")\n            }\n        )\n    }\n    else{\n        knitr::knit(.RmdFile, paste(.filename, \".md\", sep=\"\"), quiet=TRUE)\n        .html.file <- paste(.filename, \".html\", sep=\"\")\n        markdown::markdownToHTML(paste(.filename, \".md\", sep=\"\"), .html.file)\n        .html.file.location <- paste(\"file:///\", normalizePath(.html.file), sep=\"\")\n        Message(paste(gettextRcmdr(\"HTML file written to:\"), normalizePath(.html.file)), type=\"note\")\n        browseURL(.html.file.location)\n    }\n}\n\n# the following functions to support knitr\n\nbeginRnwBlock <- function(){\n    .rnw <- RnwWindow()\n    last2 <- tclvalue(tkget(.rnw, \"end -2 chars\", \"end\"))\n    if (last2 != \"\\n\\n\") tkinsert(.rnw, \"end\", \"\\n\")\n    tkinsert(.rnw, \"end\", \"\\n\")\n    tkinsert(.rnw, \"end\", \"\\\\newpage\\n\")\n    tkinsert(.rnw, \"end\", \"<<>>=\\n\")\n}\n\nendRnwBlock <- function(){\n    .rnw <- RnwWindow()\n    rnw <- tclvalue(tkget(.rnw, \"1.0\", \"end\"))\n    rnw <- paste(substring(rnw, 1, nchar(rnw) - 1), \"@\\n\", sep=\"\")\n    rnw <- trimHangingEndRnwBlock(rnw)\n    rmw <- trimTrailingNewLines(rnw)\n    tkdelete(.rnw, \"1.0\", \"end\")\n    tkinsert(.rnw, \"end\", rnw)\n    tkyview.moveto(.rnw, 1)    \n}\n\nremoveNullRnwBlocks <- function(){\n    .rnw <- RnwWindow()\n    rnw <- tclvalue(tkget(.rnw, \"1.0\", \"end\"))\n    rnw <- gsub(\"\\n+$\", \"\\n\", rnw)\n    rnw <- gsub(\"<<>>=\\n$\", \"\", rnw)\n    rnw <- gsub(\"<<>>=\\n@\\n$\", \"\", rnw)\n    rnw <- gsub(\"\\\\\\\\newpage\\n*$\", \"\", rnw)\n    rnw <- gsub(\"\\\\\\\\newpage\\n*$\", \"\", rnw)\n    tkdelete(.rnw, \"1.0\", \"end\")\n    tkinsert(.rnw, \"end\", rnw)\n    tkyview.moveto(.rnw, 1)\n}\n\nremoveStrayRnwBlocks <- function(){\n    .rnw <- RnwWindow()\n    rnw <- tclvalue(tkget(.rnw, \"1.0\", \"end\"))\n    rnw <- strsplit(rnw, \"\\\\n\")[[1]]\n    starts <- grep(\"^<<.*>>=$\", rnw)\n    ends  <- grep(\"^@$\", rnw)\n    n.ends <- length(ends)\n    j <- 1\n    if (length(starts) > 1){\n        for (i in (length(starts) - 1)){\n            if (j > n.ends || ends[j] > starts[i + 1]) {\n                rnw[starts[i]] <- \"\"\n            }\n            else {\n                j <- j + 1\n                next\n            }\n        }\n    }\n    else return()\n    rnw <- paste(rnw, collapse=\"\\n\")\n    tkdelete(.rnw, \"1.0\", \"end\")\n    tkinsert(.rnw, \"end\", rnw)\n    tkyview.moveto(.rnw, 1)\n}\n\nenterKnitr <- function(command){\n    .rnw <- RnwWindow()\n    if (!getRcmdr(\"use.knitr\")) return()\n    command <- splitCmd(command)\n    beginRnwBlock()\n    tkinsert(.rnw, \"end\", paste(command, \"\\n\", sep=\"\"))\n    tkyview.moveto(.rnw, 1)\n    putRcmdr(\"knitr.output\", TRUE)\n    endRnwBlock()\n    command\n}\n\ntrimHangingEndRnwBlock <- function(string){\n    loc.ats <- gregexpr(\"@\\n\", string)[[1]]\n    n.ats <- length(loc.ats)\n    if (n.ats > 1){\n        substr <- substring(string, loc.ats[n.ats - 1], loc.ats[n.ats])\n        if (!grepl(\"<<>>=\", substr)){\n            string <- cutstring(string, loc.ats[n.ats], loc.ats[n.ats] + 1)\n        }\n    }\n    string\n}\n\nremoveLastRnwBlock <- function(){\n    .rnw <- RnwWindow()\n    rnw <- tclvalue(tkget(.rnw, \"1.0\", \"end\"))\n    start <- gregexpr(\"\\\\\\\\newpage\\n<<>>=\\n\", rnw)\n    if (start[[1]][1] > 0){\n        start <- start[[1]]\n        start <- start[length(start)]\n        tail <- substring(rnw, start, nchar(rnw))\n        end <- gregexpr(\"@\\n\", tail)\n        end <- if (end[[1]][1] > 0) end[[1]][1] + 1 else nchar(tail)\n        rnw <- cutstring(rnw, start, start + end)\n        rnw <- trimTrailingNewLines(rnw)\n        tkdelete(.rnw, \"1.0\", \"end\")\n        tkinsert(.rnw, \"end\", rnw)\n        tkyview.moveto(.rnw, 1)\n    }\n}\n\ncompileRnw <- function(){\n    .RnwFile <- getRcmdr(\"RnwFileName\")\n    rnwDir <- dirname(.RnwFile)\n    saveDir <- setwd(rnwDir)\n    on.exit(setwd(saveDir))\n    fig.files <- list.files(\"./figure\")\n    fig.files <- fig.files[grep(\"^unnamed-chunk-[0-9]*\\\\..*$\", fig.files)]\n    if (length(fig.files) != 0) {\n        response <- tkmessageBox(message = gettextRcmdr(\"Delete previously created knitr\\ngraphics files (recommended)?\"),\n            icon = \"question\", type = \"okcancel\", default = \"ok\")\n        if (tclvalue(response) == \"ok\") unlink(paste(\"./figure/\", fig.files, sep=\"\"))\n    }\n    removeStrayRnwBlocks()\n    lines <- tclvalue(tkget(RnwWindow(), \"1.0\", \"end\"))\n    lines <- paste(lines, \"\\n\\\\end{document}\\n\")\n    .filename <- sub(\"\\\\.Rnw$\", \"\", trim.blanks(.RnwFile))\n    writeLines(lines, .RnwFile)\n    knitr::knit2pdf(.RnwFile)\n    .pdf.file <- paste(.filename, \".pdf\", sep=\"\")\n    .pdf.file.location <- paste(\"file:///\", normalizePath(.pdf.file), sep=\"\")\n    browseURL(.pdf.file.location)\n}\n\n\nknitrP <- function(){\n    getRcmdr(\"log.commands\") && getRcmdr(\"use.knitr\")\n}\n\n# editor for R Markdown and knitr documents\n\nRcmdrEditor <- function(buffer, title=\"R Commander Editor\", ok,\n                        help=NULL, file.menu=NULL, edit.menu=NULL, context.menu=NULL, toolbar.buttons=NULL){\n  contextMenu <- function(){\n    contextMenu <- tkmenu(tkmenu(editor), tearoff=FALSE)\n    if (!is.null(context.menu)){\n      for (item in context.menu){\n        tkadd(contextMenu, \"command\", label=gettextRcmdr(item$label), command=item$command)\n      }\n      tkadd(contextMenu, \"separator\")\n    }\n    tkadd(contextMenu, \"command\", label=gettextRcmdr(\"Cut\"), command=onCut)\n    tkadd(contextMenu, \"command\", label=gettextRcmdr(\"Copy\"), command=onCopy)\n    tkadd(contextMenu, \"command\", label=gettextRcmdr(\"Paste\"), command=onPaste)\n    tkadd(contextMenu, \"command\", label=gettextRcmdr(\"Delete\"), command=onDelete)\n    tkadd(contextMenu, \"separator\")\n    tkadd(contextMenu, \"command\", label=gettextRcmdr(\"Find...\"), command=onFind)\n    tkadd(contextMenu, \"command\", label=gettextRcmdr(\"Select all\"), command=onSelectAll)\n    tkadd(contextMenu, \"separator\")\n    tkadd(contextMenu, \"command\", label=gettextRcmdr(\"Undo\"), command=onUndo)\n    tkadd(contextMenu, \"command\", label=gettextRcmdr(\"Redo\"), command=onRedo)\n    tkadd(contextMenu, \"separator\")\n    tkadd(contextMenu, \"command\", label=gettextRcmdr(\"Clear window\"), command=onClear)\n    tkpopup(contextMenu, tkwinfo(\"pointerx\", editor), tkwinfo(\"pointery\", editor))\n  }\n  onCopy <- function(){\n    selection <- strsplit(tclvalue(tktag.ranges(editor, \"sel\")), \" \")[[1]]\n    if (is.na(selection[1])) return()\n    text <- tclvalue(tkget(editor, selection[1], selection[2]))\n    tkclipboard.clear()\n    tkclipboard.append(text)\n  }\n  onDelete <- function(){\n    selection <- strsplit(tclvalue(tktag.ranges(editor, \"sel\")), \" \")[[1]]\n    if (is.na(selection[1])) return()\n    tkdelete(editor, selection[1], selection[2])\n  }\n  onCut <- function(){\n    onCopy()\n    onDelete()\n  }\n  onPaste <- function(){\n    onDelete()\n    text <- tclvalue(.Tcl(\"selection get -selection CLIPBOARD\"))\n    if (length(text) == 0) return()\n    tkinsert(editor, \"insert\", text)\n  }\n  onFind <- function(){\n    initializeDialog(title=gettextRcmdr(\"Find\"))\n    textFrame <- tkframe(top)\n    textVar <- tclVar(getRcmdr(\"last.search\"))\n    textEntry <- ttkentry(textFrame, width=\"20\", textvariable=textVar)\n    checkBoxes(frame=\"optionsFrame\", boxes=c(\"regexpr\", \"case\"), initialValues=c(\"0\", \"1\"),\n               labels=gettextRcmdr(c(\"Regular-expression search\", \"Case sensitive\")))\n    radioButtons(name=\"direction\", buttons=c(\"foward\", \"backward\"), labels=gettextRcmdr(c(\"Forward\", \"Backward\")),\n                 values=c(\"-forward\", \"-backward\"), title=gettextRcmdr(\"Search Direction\"))\n    onOK <- function(){\n      text <- tclvalue(textVar)\n      putRcmdr(\"last.search\", text)\n      if (text == \"\"){\n        errorCondition(recall=onFind, message=gettextRcmdr(\"No search text specified.\"))\n        return()\n      }\n      type <- if (tclvalue(regexprVariable) == 1) \"-regexp\" else \"-exact\"\n      case <- tclvalue(caseVariable) == 1\n      direction <- tclvalue(directionVariable)\n      stop <- if (direction == \"-forward\") \"end\" else \"1.0\"\n      where.txt <- if (case) tksearch(editor, type, direction, \"--\", text, \"insert\", stop)\n      else tksearch(editor, type, direction, \"-nocase\", \"--\", text, \"insert\", stop)\n      where.txt <- tclvalue(where.txt)\n      if (where.txt == \"\") {\n        Message(message=gettextRcmdr(\"Text not found.\"),\n                type=\"note\")\n        if (GrabFocus()) tkgrab.release(top)\n        tkdestroy(top)\n        tkfocus(CommanderWindow())\n        return()\n      }\n      if (GrabFocus()) tkgrab.release(top)\n      tkfocus(editor)\n      tkmark.set(editor, \"insert\", where.txt)\n      tksee(editor, where.txt)\n      tkdestroy(top)\n    }\n    .exit <- function(){\n      text <- tclvalue(textVar)\n      putRcmdr(\"last.search\", text)\n      return(\"\")\n    }\n    OKCancelHelp()\n    tkgrid(labelRcmdr(textFrame, text=gettextRcmdr(\"Search for:\")), textEntry, sticky=\"w\")\n    tkgrid(textFrame, sticky=\"w\")\n    tkgrid(optionsFrame, sticky=\"w\")\n    tkgrid(directionFrame, sticky=\"w\")\n    tkgrid(buttonsFrame, sticky=\"w\")\n    dialogSuffix(focus=textEntry)\n  }\n  onSelectAll <- function() {\n    tktag.add(editor, \"sel\", \"1.0\", \"end\")\n    tkfocus(editor)\n  }\n  onClear <- function(){\n    onSelectAll()\n    onDelete()\n  }\n  onUndo <- function(){\n    tcl(editor, \"edit\", \"undo\")\n  }\n  onRedo <- function(){\n    tcl(editor, \"edit\", \"redo\")\n  }\n  initializeDialog(title = gettextRcmdr(title), suppress.window.resize.buttons=FALSE)\n  toolbarFrame <- tkframe(top) \n  cutButton <- buttonRcmdr(toolbarFrame, image=\"::image::cutIcon\", command=onCut)\n  copyButton <- buttonRcmdr(toolbarFrame, image=\"::image::copyIcon\", command=onCopy)\n  pasteButton <- buttonRcmdr(toolbarFrame, image=\"::image::pasteIcon\", command=onPaste)\n  deleteButton <- buttonRcmdr(toolbarFrame, image=\"::image::deleteIcon\", command=onDelete)\n  undoButton <- buttonRcmdr(toolbarFrame, image=\"::image::undoIcon\", command=onUndo)\n  redoButton <- buttonRcmdr(toolbarFrame, image=\"::image::redoIcon\", command=onRedo)\n  findButton <- buttonRcmdr(toolbarFrame, image=\"::image::findIcon\", command=onFind)\n  if (!is.null(toolbar.buttons)){\n    for (i in 1:length(toolbar.buttons)){\n      tool <- toolbar.buttons[[i]]\n      assign(paste(\"var\", i, sep=\"\"), tclVar(gettextRcmdr(tool$label)))\n      assign(paste(\"button\", i, sep=\"\"), buttonRcmdr(toolbarFrame, textvariable=eval(parse(text=paste(\"var\", i, sep=\"\"))), \n                                                     borderwidth=\"2\", command=tool$command, image=tool$image, compound=\"left\"))\n    }\n  }\n  editorFrame <- tkframe(top)\n  screenheight <- as.numeric(.Tcl(paste(\"winfo screenheight\", top$ID)))\n  char.size <- as.numeric(.Tcl(paste(\"font metrics\", getRcmdr('logFont'))))[6]\n  width <- as.numeric(tkcget(LogWindow(), \"-width\")) + 5\n  height <- max(floor(screenheight/(2.5*char.size)), 25)   \n  editor <- tktext(editorFrame, bg = \"white\", font = getRcmdr(\"logFont\"), \n                   height = height, width = width, wrap = \"none\", undo=TRUE)\n  putRcmdr(\"editor.text\", editor)\n  editorXscroll <- ttkscrollbar(editorFrame, orient = \"horizontal\", \n                                command = function(...) tkxview(editor, ...))\n  editorYscroll <- ttkscrollbar(editorFrame, command = function(...) tkyview(editor, \n                                                                             ...))\n  tkconfigure(editor, xscrollcommand = function(...) tkset(editorXscroll, \n                                                           ...))\n  tkconfigure(editor, yscrollcommand = function(...) tkset(editorYscroll, \n                                                           ...))\n  tkinsert(editor, \"1.0\", buffer)\n#  putRcmdr(\"buffer\", NULL)\n  onOK <- function(){\n#    putRcmdr(\"buffer\", tclvalue(tkget(editor, \"1.0\", \"end\")))\n    ok()\n    closeDialog()\n  }\n  .exit <- function(){\n    answer <- RcmdrTkmessageBox(\"Discard edits?\", icon=\"question\", type=\"yesno\")\n    if (as.character(answer) == \"no\") \"abort\" else \"\"\n  }\n  OKCancelHelp(helpSubject = \"ScriptEditor\")\n  editorMenu <- tkmenu(top)\n  tkconfigure(top, menu = editorMenu)\n  fileMenu <- tkmenu(editorMenu, tearoff=FALSE)\n  if (!is.null(file.menu)){\n    for (item in file.menu){\n      tkadd(fileMenu, \"command\", label=gettextRcmdr(item$label), command=item$command)\n    }\n    tkadd(fileMenu, \"separator\")\n  }\n  tkadd(fileMenu, \"command\", label=gettextRcmdr(\"Exit editor\"), command=onOK)\n  tkadd(fileMenu, \"command\", label=gettextRcmdr(\"Cancel\"), command=onCancel)\n  tkadd(editorMenu, \"cascade\", label=gettextRcmdr(\"File\"), menu=fileMenu)\n  editMenu <- tkmenu(editorMenu, tearoff=FALSE)\n  if (!is.null(edit.menu)){\n    for (item in edit.menu){\n      tkadd(editMenu, \"command\", label=gettextRcmdr(item$label), command=item$command)\n    }\n    tkadd(editMenu, \"separator\")\n  }\n  tkadd(editMenu, \"command\", label=gettextRcmdr(\"Cut\"), command=onCut)\n  tkadd(editMenu, \"command\", label=gettextRcmdr(\"Copy\"), command=onCopy)\n  tkadd(editMenu, \"command\", label=gettextRcmdr(\"Paste\"), command=onPaste)\n  tkadd(editMenu, \"command\", label=gettextRcmdr(\"Delete\"), command=onDelete)\n  tkadd(editMenu, \"separator\")\n  tkadd(editMenu, \"command\", label=gettextRcmdr(\"Find...\"), command=onFind)\n  tkadd(editMenu, \"command\", label=gettextRcmdr(\"Select all\"), command=onSelectAll)\n  tkadd(editMenu, \"separator\")\n  tkadd(editMenu, \"command\", label=gettextRcmdr(\"Undo\"), command=onUndo)\n  tkadd(editMenu, \"command\", label=gettextRcmdr(\"Redo\"), command=onRedo)\n  tkadd(editMenu, \"separator\")\n  tkadd(editMenu, \"command\", label=gettextRcmdr(\"Clear window\"), command=onClear)\n  tkadd(editorMenu, \"cascade\", label=gettextRcmdr(\"Edit\"), menu=editMenu)\n  helpMenu <- tkmenu(editorMenu, tearoff=FALSE)\n  onEditorHelp <- function() print(help(\"ScriptEditor\", package=\"Rcmdr\"))\n  tkadd(helpMenu, \"command\", label=gettextRcmdr(\"Editor help\"), command=onEditorHelp)\n  if (!is.null(help)){\n    tkadd(helpMenu, \"command\", label=gettextRcmdr(help$label), command=help$command)\n  }\n  tkadd(editorMenu, \"cascade\", label=gettextRcmdr(\"Help\"), menu=helpMenu)\n  tkgrid(editor, editorYscroll, sticky = \"nsew\")\n  tkgrid(editorXscroll)\n  if (!is.null(toolbar.buttons)){\n    for (i in 1:length(toolbar.buttons)){\n      tkgrid(eval(parse(text=paste(\"button\", i, sep=\"\"))), sticky=\"w\", row=0, column=i - 1,\n             padx=c(3, 3), pady=c(0, 8))\n    }\n  }\n  else i <- 0\n  tkgrid(cutButton, sticky=\"w\", row=0, column=i, padx=c(3, 3), pady=c(0, 8))\n  tkgrid(copyButton, sticky=\"w\", row=0, column=i + 1, padx=c(3, 3), pady=c(0, 8))\n  tkgrid(pasteButton, sticky=\"w\", row=0, column=i + 2, padx=c(3, 3), pady=c(0, 8))\n  tkgrid(deleteButton, sticky=\"w\", row=0, column=i + 3, padx=c(3, 3), pady=c(0, 8))\n  tkgrid(undoButton, sticky=\"w\", row=0, column=i + 4, padx=c(3, 3), pady=c(0, 8))\n  tkgrid(redoButton, sticky=\"w\", row=0, column=i + 5, padx=c(3, 3), pady=c(0, 8))\n  tkgrid(findButton, sticky=\"w\", row=0, column=i + 6, padx=c(3, 3), pady=c(0, 8))\n  tkgrid(toolbarFrame, sticky=\"w\")\n  tk2tip(cutButton, gettextRcmdr(\"Cut\"))\n  tk2tip(copyButton, gettextRcmdr(\"Copy\"))\n  tk2tip(pasteButton, gettextRcmdr(\"Paste\"))\n  tk2tip(deleteButton, gettextRcmdr(\"Delete\"))\n  tk2tip(undoButton, gettextRcmdr(\"Undo\"))\n  tk2tip(redoButton, gettextRcmdr(\"Redo\"))\n  tk2tip(findButton, gettextRcmdr(\"Find\"))\n  tkgrid(editorFrame, sticky = \"nsew\")\n  tkgrid.configure(editorXscroll, sticky = \"ew\")\n  tkgrid.configure(editorYscroll, sticky = \"ns\")\n  tkgrid.configure(editor, sticky = \"nsew\")\n  tkgrid.configure(editorFrame, sticky = \"nsew\")\n  tkgrid(buttonsFrame, sticky = \"ew\")\n  tkbind(top, \"<ButtonPress-3>\", contextMenu)\n  tkbind(top, \"<Control-x>\", onCut)\n  tkbind(top, \"<Control-X>\", onCut)\n  tkbind(top, \"<Control-c>\", onCopy)\n  tkbind(top, \"<Control-C>\", onCopy)\n  tkbind(top, \"<Control-f>\", onFind)\n  tkbind(top, \"<Control-F>\", onFind)\n  tkbind(top, \"<F3>\", onFind)\n  tkbind(top, \"<Control-a>\", onSelectAll)\n  tkbind(top, \"<Control-A>\", onSelectAll)\n  tkbind(top, \"<Control-w>\", onRedo)\n  tkbind(top, \"<Control-W>\", onRedo)\n  tkbind(top, \"<Alt-BackSpace>\", onUndo)\n  if (MacOSXP()){\n    tkbind(top, \"<Meta-x>\", onCut)\n    tkbind(top, \"<Meta-X>\", onCut)\n    tkbind(top, \"<Meta-c>\", onCopy)\n    tkbind(top, \"<Meta-C>\", onCopy)\n    tkbind(top, \"<Meta-v>\", onPaste)\n    tkbind(top, \"<Meta-V>\", onPaste)\n    tkbind(top, \"<Meta-f>\", onFind)\n    tkbind(top, \"<Meta-F>\", onFind)\n    tkbind(top, \"<Meta-a>\", onSelectAll)\n    tkbind(top, \"<Meta-A>\", onSelectAll)\n    tkbind(top, \"<Meta-w>\", onRedo)\n    tkbind(top, \"<Meta-W>\", onRedo)\n  }\n  tkwm.protocol(top, \"WM_DELETE_WINDOW\", onCancel)\n  dialogSuffix(bindReturn = FALSE, resizable=TRUE, focus=editor)\n  tkgrid.rowconfigure(top, 0, weight = 0)\n  tkgrid.rowconfigure(top, 1, weight = 1)\n  tkgrid.rowconfigure(top, 2, weight = 0)\n  tkgrid.columnconfigure(top, 0, weight=1)\n  tkgrid.rowconfigure(editorFrame, 1, weight=0)\n  tkgrid.rowconfigure(editorFrame, 0, weight=1)\n  tkgrid.columnconfigure(editorFrame, 0, weight=1)\n  tkgrid.columnconfigure(editorFrame, 1, weight=0)\n}\n\n# the rgb2col function translates #RRGGBB colors to names if a named color exists or otherwise a \"close\" color (not exported)\n#  uses code from r-help adapted from Kevin Wright\n\nrgb2col <- local({\n    all.names <- colors(distinct=TRUE)\n    all.lab <- t(convertColor(t(col2rgb(all.names)), from = \"sRGB\", \n        to = \"Lab\", scale.in = 255))\n    findNear <- function(x.lab) {\n        sq.dist <- colSums((all.lab - x.lab)^2)\n        rbind(all.names[which.min(sq.dist)], min(sq.dist))\n    }\n    function(cols.hex, near = 15) { # near = 2.3 is nominally the JND\n        cols.lab <- t(convertColor(t(col2rgb(cols.hex)), from = \"sRGB\", \n            to = \"Lab\", scale.in = 255))\n        cols.near <- apply(cols.lab, 2, findNear)\n        ifelse(as.numeric(cols.near[2, ]) < near^2, cols.near[1, ], toupper(cols.hex))\n    }\n})\n\n# the following function is for plug-ins that test for SciViews (which is no longer supported)\n\nis.SciViews <- function() FALSE\n\n# the following two functions from Milan Bouchet-Valat\n\nsetBusyCursor <- function() {\n    .commander <- CommanderWindow()\n    .menu <- tkcget(.commander, menu=NULL)\n    .log <- LogWindow()\n    .output <- OutputWindow()\n    .messages <- MessagesWindow()\n    \n    tkconfigure(.commander, cursor=\"watch\")\n    tkconfigure(.menu, cursor=\"watch\")\n    tkconfigure(.log, cursor=\"watch\")\n    tkconfigure(.output, cursor=\"watch\")\n    tkconfigure(.messages, cursor=\"watch\")\n}\n\nsetIdleCursor <- function() {\n    .commander <- CommanderWindow()\n    .menu <- tkcget(.commander, menu=NULL)\n    .log <- LogWindow()\n    .output <- OutputWindow()\n    .messages <- MessagesWindow()\n    \n    tkconfigure(.commander, cursor=\"\")\n    tkconfigure(.menu, cursor=\"\")\n    tkconfigure(.log, cursor=\"xterm\")\n    tkconfigure(.output, cursor=\"xterm\")\n    tkconfigure(.messages, cursor=\"xterm\")\n}\n\n\n# hasJava <- function(){\n#   getRcmdr(\"capabilities\")$java\n# }\n\n# setupHelp <- function(){\n#   if (MacOSXP() && .Platform$GUI == \"AQUA\"){\n#     current <- system(\"defaults read org.R-project.R\", intern=TRUE)\n#     use.external.help <- grep(\"use.external.help\", current)\n#     if (length(use.external.help) < 1 || \n#           length(grep(\"YES\", current[use.external.help])) < 1){\n#       system(\"defaults write org.R-project.R use.external.help YES\")\n#       putRcmdr(\"restore.use.external.help\", TRUE)\n#     }\n#   }\n# }\n\n# Rcmdr data editor\n\neditDataset <- function(data, dsname){\n  putRcmdr(\"dataset.modified\", FALSE)\n  if (missing(data)){\n    if (missing(dsname)) dsname <- \"Dataset\"\n    data <- data.frame(V1=\"NA\")\n  }\n  else {\n    if (!inherits(data, \"data.frame\")) stop (\"data argument must be a data frame\")\n    if (missing(dsname)) dsname <- deparse(substitute(data))\n  }\n  if (getRcmdr(\"crisp.dialogs\")) tclServiceMode(on=FALSE)\n  top <- tktoplevel(borderwidth = 10)\n  tkwm.title(top, paste(gettextRcmdr(\"Data Editor\"), \": \", dsname, sep=\"\"))\n  location <- getRcmdr(\"open.dialog.here\")\n  pos <- 10 + commanderPosition()\n  position <- if (any(pos < 0)) \"-50+50\" \n  else paste(\"+\", paste(pos, collapse = \"+\"), sep = \"\")\n  tkwm.geometry(top, position)\n  #  tkwm.geometry(top, '-20+200')\n  tcl.array <- tclArray()\n  nr <- nrow(data)\n  nc <- ncol(data)\n  for (j in 1:nc){\n    data.column <- as.character(data[, j])\n    data.column[is.na(data.column)] <- \"NA\"\n    data[, j] <- data.column\n  }\n  colnames <- colnames(data)\n  rownames <- rownames(data)\n  putRcmdr(\"data.dim\", list(nr=nr, nc=nc, NR=nr, NC=nc))\n  # NR, NC not decremented on row/column deletion\n  #   to avoid possibly duplicate \n  #   auto-generated row/column names\n  for (i in 1:nr) {\n    tcl.array[[i + 1, 0]] <- i\n    tcl.array[[i + 1, 1]] <- rownames[i]\n  }\n  for (j in 1:nc){\n    tcl.array[[0, j + 1]] <- j\n    tcl.array[[1, j + 1]] <- colnames[j]\n  }\n  tcl.array[[1, 1]] <- \"rowname\"\n  for (i in 1:nr){\n    for (j in 1:nc){\n      tcl.array[[i + 1, j + 1]] <- data[i, j]\n    }\n  }\n  tableFrame <- tkframe(top)\n  data.table <- tk2table(tableFrame, rows=nr + 2, cols=nc + 2, \n                         titlerows=1, titlecols=1,\n                         width=nc + 2, height=nr + 2, sparsearray=0,\n                         cache=1, flashmode=1, autoclear=1, wrap=1, \n                         colstretchmode=\"all\", rowstretchmode=\"all\",\n                         font=getRcmdr('logFont'), anchor=\"e\", padx=6, \n                         resizeborders=\"both\", drawmode=\"slow\",\n                         xscrollcommand=function(...) tkset(xscroll,...),\n                         yscrollcommand=function(...) tkset(yscroll,...))\n  tcl(data.table, \"width\", 0, max(max(nchar(as.character(nr))), 3))\n  tcl(data.table, \"width\", 1, max(max(nchar(c(rownames, \"rowname\"))), 3))\n  for (j in 1:nc){\n    tcl(data.table, \"width\", j + 1, \n        max(max(nchar(c(colnames[j], data[, j]))), 8))\n  }\n  xscroll <- ttkscrollbar(tableFrame, orient=\"horizontal\", \n                          command=function(...) tkxview(data.table,...))\n  yscroll <- ttkscrollbar(tableFrame,\n                          command=function(...) tkyview(data.table,...))\n  deleteCell <- function() {\n    result <- try(tkdelete(data.table, \"active\", \"0\", \"end\"), silent=TRUE)\n    if (inherits(result, \"try-error\")) return()\n    tkinsert(data.table, \"active\", \"0\", \"NA\")\n  }\n  copyCell <- function(){\n    text <- try(tclvalue(tkget(data.table, \"active\")), silent=TRUE)\n    if (inherits(text, \"try-error\")) return()\n    tkclipboard.clear()\n    tkclipboard.append(text)\n  }\n  pasteCell <- function(){\n    text <- tclvalue(.Tcl(\"selection get -selection CLIPBOARD\"))\n    if (length(text) == 0) return()\n    result <- try(tkdelete(data.table, \"active\", \"0\", \"end\"), silent=TRUE)\n    if (inherits(result, \"try-error\")) return()\n    tkinsert(data.table, \"active\", \"0\", text)\n  }\n  cutCell <- function(){\n    copyCell()\n    deleteCell()\n  }\n  addRow <- function(){\n    dims <- getRcmdr(\"data.dim\")\n    nr <- dims$nr + 2\n    nc <- dims$nc + 1\n    NR <- dims$NR + 1\n    NC <- dims$NC\n    tkinsert(data.table, \"row\", nr + 1, 1)\n    putRcmdr(\"data.dim\", list(nr=nr - 1, nc=nc - 1, NR=NR, NC=NC))\n    tcl.array[[nr, 0]] <- NR\n    tcl.array[[nr, 1]] <- NR\n    for (j in 1:nc) tcl.array[[nr, j + 1]] <- \"NA\"\n    tkconfigure(data.table, width=nc + 1, height=nr + 1)\n    tkactivate(data.table, paste0(nr, \",\", 2))\n    tcl(data.table, \"yview\", nr)\n    tcl(data.table, \"xview\", 0)\n  }\n  addCol <- function(){\n    dims <- getRcmdr(\"data.dim\")\n    nr <- dims$nr + 1\n    nc <- dims$nc + 2\n    NR <- dims$NR\n    NC <- dims$NC + 1\n    tkinsert(data.table, \"cols\", nc + 1, 1)\n    putRcmdr(\"data.dim\", list(nr=nr - 1, nc=nc - 1, NR=NR, NC=NC))\n    tcl.array[[0, nc]] <- NC\n    tcl.array[[1, nc]] <- paste(\"V\", NC, sep=\"\")\n    for (i in 1:nr) tcl.array[[i + 1, nc]] <- \"NA\"\n    tkconfigure(data.table, width=nc + 1, height=nr + 1)\n    tkactivate(data.table, paste0(2, \",\", nc))\n    tcl(data.table, \"xview\", nc)\n    tcl(data.table, \"yview\", 0)\n  }\n  deleteRow <- function(){\n    result <- try(tkdelete(data.table , \"rows\",\n                           tclvalue(tkindex(data.table, \"active\" ,\"row\")), 1),\n                  silent=TRUE)\n    if (inherits(result, \"try-error\")) return()\n    dims <- getRcmdr(\"data.dim\")\n    nr <- dims$nr - 1\n    nc <- dims$nc\n    NR <- dims$NR\n    NC <- dims$NC\n    putRcmdr(\"data.dim\", list(nr=nr, nc=nc, NR=NR, NC=NC))\n  }\n  deleteCol <- function(){\n    result <- try(tkdelete(data.table , \"cols\",\n                           tclvalue(tkindex(data.table, \"active\" ,\"col\")), 1),\n                  silent=TRUE)\n    if (inherits(result, \"try-error\")) return()\n    dims <- getRcmdr(\"data.dim\")\n    nr <- dims$nr\n    nc <- dims$nc - 1\n    NR <- dims$NR\n    NC <- dims$NC\n    putRcmdr(\"data.dim\", list(nr=nr, nc=nc, NR=NR, NC=NC))\n  }\n  onContextMenu <- function(){\n    contextMenu <- tkmenu(tkmenu(data.table), tearoff=FALSE)\n    tkadd(contextMenu, \"command\", label=gettextRcmdr(\"Delete current row\"), \n          command=deleteRow)\n    tkadd(contextMenu, \"command\", label=gettextRcmdr(\"Delete current column\"),\n          command=deleteCol)\n    tkadd(contextMenu, \"command\", label=gettextRcmdr(\"Delete cell\"), \n          command=deleteCell)\n    tkadd(contextMenu, \"command\", label=gettextRcmdr(\"Cut cell\"), \n          command=cutCell)\n    tkadd(contextMenu, \"command\", label=gettextRcmdr(\"Copy cell\"), \n          command=copyCell)\n    tkadd(contextMenu, \"command\", label=gettextRcmdr(\"Paste cell\"), \n          command=pasteCell)\n    tkpopup(contextMenu, tkwinfo(\"pointerx\", data.table), \n            tkwinfo(\"pointery\", data.table))\n  }\n  onOK <- function(){\n    closeDialog()\n    dims <- getRcmdr(\"data.dim\")\n    nr <- dims$nr + 1\n    nc <- dims$nc + 1\n    data <- matrix(\"\", nc + 1, nr)\n    for (i in 1:nr){\n      for (j in 1:nc){\n        data[j, i] <- tclvalue(tcl.array[[i, j]])\n        if (trim.blanks(data[j, i]) == \"\") data[j, i] <- \"NA\"\n      }\n      data[nc + 1, i] <- \"\\n\"\n    }\n    data <- paste(data[-1], collapse=\" \")\n    Data <- read.table(textConnection(data), header=TRUE)\n    gassign(dsname, Data)\n    activeDataSet(dsname)\n    putRcmdr(\"dataset.modified\", TRUE)\n  }\n  onReturn <- function(){\n    location <- try(as.numeric(unlist(strsplit(tclvalue(tkindex(data.table, \"active\")), \",\"))), \n                    silent=TRUE)\n    if (inherits(location, \"try-error\")) return()\n    text <- tclvalue(tcl.array[[location[1], location[2]]])\n    on.exit(tcl.array[[location[1], location[2]]] <- sub(\"\\n\", \"\", text))\n    addRow()\n  }\n  .exit <- function(){\n    answer <- RcmdrTkmessageBox(\"Discard edits?\", icon=\"question\", type=\"yesno\", default=\"no\")\n    if (as.character(answer) == \"no\") \"abort\" else \"\"\n  }\n  OKCancelHelp(helpSubject=\"editDataset\")\n  editorMenu <- tkmenu(top)\n  tkconfigure(top, menu = editorMenu)\n  fileMenu <- tkmenu(editorMenu, tearoff=FALSE)\n  tkadd(fileMenu, \"command\", label=gettextRcmdr(\"Exit and save\"), command=onOK)\n  tkadd(fileMenu, \"command\", label=gettextRcmdr(\"Cancel\"), command=onCancel)\n  tkadd(editorMenu, \"cascade\", label=gettextRcmdr(\"File\"), menu=fileMenu)   \n  editMenu <- tkmenu(editorMenu, tearoff=FALSE)\n  tkadd(editMenu, \"command\", label=gettextRcmdr(\"Delete current row\"), \n        command=deleteRow)\n  tkadd(editMenu, \"command\", label=gettextRcmdr(\"Delete current column\"), \n        command=deleteCol)\n  tkadd(editMenu, \"command\", label=gettextRcmdr(\"Add row\"), command=addRow)\n  tkadd(editMenu, \"command\", label=gettextRcmdr(\"Add column\"), command=addCol)\n  tkadd(editMenu, \"command\", label=gettextRcmdr(\"Cut cell\"), command=cutCell)\n  tkadd(editMenu, \"command\", label=gettextRcmdr(\"Copy cell\"), command=copyCell)\n  tkadd(editMenu, \"command\", label=gettextRcmdr(\"Paste cell\"), \n        command=pasteCell)\n  tkadd(editorMenu, \"cascade\", label=gettextRcmdr(\"Edit\"), menu=editMenu)   \n  helpMenu <- tkmenu(editorMenu, tearoff=FALSE)\n  onEditorHelp <- function() print(help(\"editDataset\"))\n  tkadd(helpMenu, \"command\", label=gettextRcmdr(\"Editor help\"), \n        command=onEditorHelp)\n  tkadd(editorMenu, \"cascade\", label=gettextRcmdr(\"Help\"), menu=helpMenu)    \n  tkbind(data.table, \"<Control-x>\", cutCell) # FIXME!\n  tkbind(data.table, \"<Control-X>\", cutCell) #  doesn't work -- source of error unclear\n  tkbind(data.table, \"<Control-c>\", copyCell)\n  tkbind(data.table, \"<Control-C>\", copyCell)\n  tkbind(data.table, \"<Control-v>\", pasteCell)\n  tkbind(data.table, \"<Control-V>\", pasteCell) \n  tkbind(data.table, \"<ButtonPress-3>\", onContextMenu)\n  tkbind(data.table, \"<Control-ButtonPress-1>\", onContextMenu)\n  tkbind(data.table, \"<Double-Button-1>\", deleteCell)\n  if (MacOSXP()){\n    tkbind(data.table, \"<Meta-x>\", cutCell) # FIXME!\n    tkbind(data.table, \"<Meta-X>\", cutCell) #  doesn't work -- source of error unclear\n    tkbind(data.table, \"<Meta-c>\", copyCell)\n    tkbind(data.table, \"<Meta-C>\", copyCell)\n    tkbind(data.table, \"<Meta-v>\", pasteCell)\n    tkbind(data.table, \"<Meta-V>\", pasteCell) \n    tkbind(data.table, \"<Meta-ButtonPress-1>\", onContextMenu)\n  }\n  buttonsAddFrame <- tkframe(top)\n  addRowButton <- ttkbutton(buttonsAddFrame, command=addRow, \n                            text=gettextRcmdr(\"Add row\"))\n  addColButton <- ttkbutton(buttonsAddFrame, command=addCol, \n                            text=gettextRcmdr(\"Add column\"))\n  tkgrid(addRowButton, addColButton, sticky=\"w\")\n  tkgrid(buttonsAddFrame, sticky=\"w\")\n  tkgrid(data.table, yscroll, sticky=\"news\")\n  tkgrid.configure(yscroll, sticky=\"ns\")\n  tkgrid(xscroll, sticky=\"ew\")\n  tkconfigure(data.table, variable=tcl.array, background=\"lightgray\", \n              selectmode=\"extended\")\n  tktag.configure(data.table, \"active\", fg=\"black\", bg=\"white\")\n  tktag.configure(data.table, \"flash\", fg=\"white\", bg=\"gray\")\n  tcl(data.table, \"tag\", \"col\", \"rownos\", 0)\n  tktag.configure(data.table, \"rownos\", anchor=\"e\")  \n  warn <- options(warn=-1)\n  on.exit(warn)\n  row.numbers <- !any(is.na(as.numeric(rownames)))\n  tcl(data.table, \"tag\", \"col\", \"rownames\", 1)\n  tktag.configure(data.table, \"rownames\", \n                  anchor=if (row.numbers) \"e\" else \"w\", bg=\"darkgray\")  \n  tcl(data.table, \"tag\", \"row\", \"colnames\", 1)\n  tktag.configure(data.table, \"colnames\", bg=\"darkgray\")  \n  tkgrid(tableFrame, sticky=\"news\")\n  tkgrid(buttonsFrame, sticky=\"w\")\n  tkwm.protocol(top, \"WM_DELETE_WINDOW\", onCancel)\n  dialogSuffix(resizable=TRUE)\n  tkgrid.rowconfigure(top, 0, weight = 0)\n  tkgrid.rowconfigure(top, 1, weight = 1)\n  tkgrid.rowconfigure(top, 2, weight = 0)\n  tkgrid.columnconfigure(top, 0, weight = 1)\n  tkgrid.rowconfigure(tableFrame, 0, weight = 1)\n  tkgrid.rowconfigure(tableFrame, 1, weight = 0)\n  tkgrid.columnconfigure(tableFrame, 0, weight = 1)\n  tkgrid.columnconfigure(tableFrame, 1, weight = 0)\n  tkconfigure(data.table, selectmode = \"extended\", rowseparator = \"\\\"\\n\\\"\", colseparator = \"\\\"\\t\\\"\")\n  tkconfigure(data.table, multiline = FALSE)\n  tkbind(top, \"<Key-Return>\", onReturn)\n  tkbind(top, \"<Key-Tab>\", addCol)\n  tkwait.window(top)\n}\n\n# editDataset <- function(data, dsname){\n#     putRcmdr(\"dataset.modified\", FALSE)\n#     if (missing(data)){\n#         if (missing(dsname)) dsname <- \"Dataset\"\n#         data <- data.frame(V1=\"NA\")\n#     }\n#     else {\n#         if (!inherits(data, \"data.frame\")) stop (\"data argument must be a data frame\")\n#         if (missing(dsname)) dsname <- deparse(substitute(data))\n#     }\n#     if (getRcmdr(\"crisp.dialogs\")) tclServiceMode(on=FALSE)\n#     top <- tktoplevel(borderwidth = 10)\n#     tkwm.title(top, paste(gettextRcmdr(\"Data Editor\"), \": \", dsname, sep=\"\"))\n# #     location <- getRcmdr(\"open.dialog.here\")  # FIXME!\n# #     pos <- 10 + commanderPosition()           # Don't do this because window doesn't stay on top\n# #     position <- if (any(pos < 0)) \"-50+50\" \n# #     else paste(\"+\", paste(pos, collapse = \"+\"), sep = \"\")\n# #     tkwm.geometry(top, position)\n#     tkwm.geometry(top, '-20+200')\n#     tcl.array <- tclArray()\n#     nr <- nrow(data)\n#     nc <- ncol(data)\n#     for (j in 1:nc){\n#         data[, j] <- as.character(data[, j])\n#     }\n#     colnames <- colnames(data)\n#     rownames <- rownames(data)\n#     putRcmdr(\"data.dim\", list(nr=nr, nc=nc, NR=nr, NC=nc))\n#     # NR, NC not decremented on row/column deletion\n#     #   to avoid possibly duplicate \n#     #   auto-generated row/column names\n#     for (i in 1:nr) {\n#         tcl.array[[i + 1, 0]] <- i\n#         tcl.array[[i + 1, 1]] <- rownames[i]\n#     }\n#     for (j in 1:nc){\n#         tcl.array[[0, j + 1]] <- j\n#         tcl.array[[1, j + 1]] <- colnames[j]\n#     }\n#     tcl.array[[1, 1]] <- \"rowname\"\n#     for (i in 1:nr){\n#         for (j in 1:nc){\n#             tcl.array[[i + 1, j + 1]] <- data[i, j]\n#         }\n#     }\n#     tableFrame <- tkframe(top)\n#     data.table <- tk2table(tableFrame, rows=nr + 2, cols=nc + 2, \n#         titlerows=1, titlecols=1,\n#         width=nc + 2, height=nr + 2, sparsearray=0,\n#         cache=1, flashmode=1, autoclear=1, wrap=1, \n#         colstretchmode=\"all\", rowstretchmode=\"all\",\n#         font=getRcmdr('logFont'), anchor=\"e\", padx=6, \n#         resizeborders=\"both\",\n#         xscrollcommand=function(...) tkset(xscroll,...),\n#         yscrollcommand=function(...) tkset(yscroll,...))\n#     tcl(data.table, \"width\", 0, max(max(nchar(as.character(nr))), 3))\n#     tcl(data.table, \"width\", 1, max(max(nchar(c(rownames, \"rowname\"))), 3))\n#     for (j in 1:nc){\n#         tcl(data.table, \"width\", j + 1, \n#             max(max(nchar(c(colnames[j], data[, j]))), 8))\n#     }\n#     xscroll <- ttkscrollbar(tableFrame, orient=\"horizontal\", \n#         command=function(...) tkxview(data.table,...))\n#     yscroll <- ttkscrollbar(tableFrame,\n#         command=function(...) tkyview(data.table,...))\n#     deleteCell <- function() {\n#         result <- try(tkdelete(data.table, \"active\", \"0\", \"end\"), silent=TRUE)\n#         if (inherits(text, \"try-error\")) return()\n#         tkinsert(data.table, \"active\", \"0\", \"NA\")\n#     }\n#     copyCell <- function(){\n#         text <- try(tclvalue(tkget(data.table, \"active\")), silent=TRUE)\n#         if (inherits(text, \"try-error\")) return()\n#         tkclipboard.clear()\n#         tkclipboard.append(text)\n#     }\n#     pasteCell <- function(){\n#         text <- tclvalue(.Tcl(\"selection get -selection CLIPBOARD\"))\n#         if (length(text) == 0) return()\n#         result <- try(tkdelete(data.table, \"active\", \"0\", \"end\"), silent=TRUE)\n#         if (inherits(text, \"try-error\")) return()\n#         tkinsert(data.table, \"active\", \"0\", text)\n#     }\n#     cutCell <- function(){\n#         copyCell()\n#         deleteCell()\n#     }\n#     addRow <- function(){\n#         dims <- getRcmdr(\"data.dim\")\n#         nr <- dims$nr + 2\n#         nc <- dims$nc + 1\n#         NR <- dims$NR + 1\n#         NC <- dims$NC\n#         tkinsert(data.table, \"row\", nr + 1, 1)\n#         putRcmdr(\"data.dim\", list(nr=nr - 1, nc=nc - 1, NR=NR, NC=NC))\n#         tcl.array[[nr, 0]] <- NR\n#         tcl.array[[nr, 1]] <- NR\n#         for (j in 1:nc) tcl.array[[nr, j + 1]] <- \"NA\"\n#         tkconfigure(data.table, width=nc + 1, height=nr + 1)\n#     }\n#     addCol <- function(){\n#         dims <- getRcmdr(\"data.dim\")\n#         nr <- dims$nr + 1\n#         nc <- dims$nc + 2\n#         NR <- dims$NR\n#         NC <- dims$NC + 1\n#         tkinsert(data.table, \"cols\", nc + 1, 1)\n#         putRcmdr(\"data.dim\", list(nr=nr - 1, nc=nc - 1, NR=NR, NC=NC))\n#         tcl.array[[0, nc]] <- NC\n#         tcl.array[[1, nc]] <- paste(\"V\", NC, sep=\"\")\n#         for (i in 1:nr) tcl.array[[i + 1, nc]] <- \"NA\"\n#         tkconfigure(data.table, width=nc + 1, height=nr + 1)\n#     }\n#     deleteRow <- function(){\n#         result <- try(tkdelete(data.table , \"rows\",\n#             tclvalue(tkindex(data.table, \"active\" ,\"row\")), 1),\n#             silent=TRUE)\n#         if (inherits(result, \"try-error\")) return()\n#         dims <- getRcmdr(\"data.dim\")\n#         nr <- dims$nr - 1\n#         nc <- dims$nc\n#         NR <- dims$NR\n#         NC <- dims$NC\n#         putRcmdr(\"data.dim\", list(nr=nr, nc=nc, NR=NR, NC=NC))\n#     }\n#     deleteCol <- function(){\n#         result <- try(tkdelete(data.table , \"cols\",\n#             tclvalue(tkindex(data.table, \"active\" ,\"col\")), 1),\n#             silent=TRUE)\n#         if (inherits(result, \"try-error\")) return()\n#         dims <- getRcmdr(\"data.dim\")\n#         nr <- dims$nr\n#         nc <- dims$nc - 1\n#         NR <- dims$NR\n#         NC <- dims$NC\n#         putRcmdr(\"data.dim\", list(nr=nr, nc=nc, NR=NR, NC=NC))\n#     }\n#     onContextMenu <- function(){\n#         contextMenu <- tkmenu(tkmenu(data.table), tearoff=FALSE)\n#         tkadd(contextMenu, \"command\", label=gettextRcmdr(\"Delete current row\"), \n#             command=deleteRow)\n#         tkadd(contextMenu, \"command\", label=gettextRcmdr(\"Delete current column\"),\n#             command=deleteCol)\n#         tkadd(contextMenu, \"command\", label=gettextRcmdr(\"Delete cell\"), \n#             command=deleteCell)\n#         tkadd(contextMenu, \"command\", label=gettextRcmdr(\"Cut cell\"), \n#             command=cutCell)\n#         tkadd(contextMenu, \"command\", label=gettextRcmdr(\"Copy cell\"), \n#             command=copyCell)\n#         tkadd(contextMenu, \"command\", label=gettextRcmdr(\"Paste cell\"), \n#             command=pasteCell)\n#         tkpopup(contextMenu, tkwinfo(\"pointerx\", data.table), \n#             tkwinfo(\"pointery\", data.table))\n#     }\n#     onOK <- function(){\n#         closeDialog()\n#         dims <- getRcmdr(\"data.dim\")\n#         nr <- dims$nr + 1\n#         nc <- dims$nc + 1\n#         data <- matrix(\"\", nc + 1, nr)\n#         for (i in 1:nr){\n#             for (j in 1:nc){\n#                 data[j, i] <- tclvalue(tcl.array[[i, j]])\n#             }\n#             data[nc + 1, i] <- \"\\n\"\n#         }\n#         data <- paste(data[-1], collapse=\" \")\n#         Data <- read.table(textConnection(data), header=TRUE)\n#         gassign(dsname, Data)\n#         activeDataSet(dsname)\n#         putRcmdr(\"dataset.modified\", TRUE)\n#     }\n#     .exit <- function(){\n#         answer <- RcmdrTkmessageBox(\"Discard edits?\", icon=\"question\", type=\"yesno\")\n#         if (as.character(answer) == \"no\") \"abort\" else \"\"\n#     }\n#     OKCancelHelp(helpSubject=\"editDataset\")\n#     editorMenu <- tkmenu(top)\n#     tkconfigure(top, menu = editorMenu)\n#     fileMenu <- tkmenu(editorMenu, tearoff=FALSE)\n#     tkadd(fileMenu, \"command\", label=gettextRcmdr(\"Exit and save\"), command=onOK)\n#     tkadd(fileMenu, \"command\", label=gettextRcmdr(\"Cancel\"), command=onCancel)\n#     tkadd(editorMenu, \"cascade\", label=gettextRcmdr(\"File\"), menu=fileMenu)   \n#     editMenu <- tkmenu(editorMenu, tearoff=FALSE)\n#     tkadd(editMenu, \"command\", label=gettextRcmdr(\"Delete current row\"), \n#         command=deleteRow)\n#     tkadd(editMenu, \"command\", label=gettextRcmdr(\"Delete current column\"), \n#         command=deleteCol)\n#     tkadd(editMenu, \"command\", label=gettextRcmdr(\"Add row\"), command=addRow)\n#     tkadd(editMenu, \"command\", label=gettextRcmdr(\"Add column\"), command=addCol)\n#     tkadd(editMenu, \"command\", label=gettextRcmdr(\"Cut cell\"), command=cutCell)\n#     tkadd(editMenu, \"command\", label=gettextRcmdr(\"Copy cell\"), command=copyCell)\n#     tkadd(editMenu, \"command\", label=gettextRcmdr(\"Paste cell\"), \n#         command=pasteCell)\n#     tkadd(editorMenu, \"cascade\", label=gettextRcmdr(\"Edit\"), menu=editMenu)   \n#     helpMenu <- tkmenu(editorMenu, tearoff=FALSE)\n#     onEditorHelp <- function() print(help(\"editDataset\"))\n#     tkadd(helpMenu, \"command\", label=gettextRcmdr(\"Editor help\"), \n#         command=onEditorHelp)\n#     tkadd(editorMenu, \"cascade\", label=gettextRcmdr(\"Help\"), menu=helpMenu)    \n#     #    tkbind(data.table, \"<Control-x>\", cutCell) # FIXME!\n#     #    tkbind(data.table, \"<Control-X>\", cutCell) #  doesn't work -- source of error unclear\n#     tkbind(data.table, \"<Control-c>\", copyCell)\n#     tkbind(data.table, \"<Control-C>\", copyCell)\n#     tkbind(data.table, \"<Control-v>\", pasteCell)\n#     tkbind(data.table, \"<Control-V>\", pasteCell) \n#     tkbind(data.table, \"<ButtonPress-3>\", onContextMenu)\n#     tkbind(data.table, \"<Control-ButtonPress-1>\", onContextMenu)\n#     tkbind(data.table, \"<Double-Button-1>\", deleteCell)\n#     if (MacOSXP()){\n#         tkbind(data.table, \"<Meta-c>\", copyCell)\n#         tkbind(data.table, \"<Meta-C>\", copyCell)\n#         tkbind(data.table, \"<Meta-v>\", pasteCell)\n#         tkbind(data.table, \"<Meta-V>\", pasteCell) \n#         tkbind(data.table, \"<Meta-ButtonPress-1>\", onContextMenu)\n#     }\n#     buttonsAddFrame <- tkframe(top)\n#     addRowButton <- ttkbutton(buttonsAddFrame, command=addRow, \n#         text=gettextRcmdr(\"Add row\"))\n#     addColButton <- ttkbutton(buttonsAddFrame, command=addCol, \n#         text=gettextRcmdr(\"Add column\"))\n#     tkgrid(addRowButton, addColButton, sticky=\"w\")\n#     tkgrid(buttonsAddFrame, sticky=\"w\")\n#     tkgrid(data.table, yscroll, sticky=\"news\")\n#     tkgrid.configure(yscroll, sticky=\"ns\")\n#     tkgrid(xscroll, sticky=\"ew\")\n#     tkconfigure(data.table, variable=tcl.array, background=\"lightgray\", \n#         selectmode=\"extended\")\n#     tktag.configure(data.table, \"active\", fg=\"black\", bg=\"white\")\n#     tktag.configure(data.table, \"flash\", fg=\"white\", bg=\"gray\")\n#     tcl(data.table, \"tag\", \"col\", \"rownos\", 0)\n#     tktag.configure(data.table, \"rownos\", anchor=\"e\")  \n#     warn <- options(warn=-1)\n#     on.exit(warn)\n#     row.numbers <- !any(is.na(as.numeric(rownames)))\n#     tcl(data.table, \"tag\", \"col\", \"rownames\", 1)\n#     tktag.configure(data.table, \"rownames\", \n#         anchor=if (row.numbers) \"e\" else \"w\", bg=\"darkgray\")  \n#     tcl(data.table, \"tag\", \"row\", \"colnames\", 1)\n#     tktag.configure(data.table, \"colnames\", bg=\"darkgray\")  \n#     tkgrid(tableFrame, sticky=\"news\")\n#     tkgrid(buttonsFrame, sticky=\"w\")\n#     tkwm.protocol(top, \"WM_DELETE_WINDOW\", onCancel)\n#     dialogSuffix(resizable=TRUE)\n#     tkgrid.rowconfigure(top, 0, weight = 0)\n#     tkgrid.rowconfigure(top, 1, weight = 1)\n#     tkgrid.rowconfigure(top, 2, weight = 0)\n#     tkgrid.columnconfigure(top, 0, weight = 1)\n#     tkgrid.rowconfigure(tableFrame, 0, weight = 1)\n#     tkgrid.rowconfigure(tableFrame, 1, weight = 0)\n#     tkgrid.columnconfigure(tableFrame, 0, weight = 1)\n#     tkgrid.columnconfigure(tableFrame, 1, weight = 0)\n#     tkwait.window(top)\n# }\n\n# some Mac OS X related functions\n\nRappP <- function() .Platform$GUI == \"AQUA\"\n\nmavericksP <- function(){\n  info <- Sys.info()\n  info[\"sysname\"] == \"Darwin\" && info[\"release\"] >= \"13.0.0\"\n}\n\nappnap <- function(state=c(\"on\", \"off\", \"delete\")){\n  if (!mavericksP()) stop(\"requires OS X 10.9 or greater\")\n  save <- options(warn = -1)\n  on.exit(options(save))\n  if (missing(state)){\n    res <- system(\"defaults read org.R-project.R NSAppSleepDisabled\", \n                  intern=TRUE, ignore.stderr=TRUE)\n    return(c(\"on\", \"off\")[1 + (length(res) > 0 && res == \"1\")])\n  }\n  state <- match.arg(state)\n  switch(state,\n         delete = system(\"defaults delete org.R-project.R NSAppSleepDisabled\", ignore.stderr=TRUE),\n         off = system(\"defaults write org.R-project.R NSAppSleepDisabled -bool YES\"),\n         on = system(\"defaults write org.R-project.R NSAppSleepDisabled -bool NO\")\n  )\n  return(state)\n}\n\n# replacement for standard tkmenu() to play better with ttk themes\n#  courtesy of Philippe Grosjean\n\ntkmenu <- function (parent, activebackground, activeforeground, ...) {\n  if (!is.ttk()) \n    stop(\"Tcl/Tk >= 8.5 is required\")\n  w <- tkwidget(parent, \"menu\", ...)\n  if (missing(activebackground)) activebackground <- tk2style(\"tk2button\", \"selectbackground\")\n  if (activebackground == \"\") activebackground = \"darkblue\" # Default value\n  if (missing(activeforeground)) activeforeground <- tk2style(\"tk2button\", \"selectforeground\")\n  if (activeforeground == \"\") activeforeground = \"white\" # Default value\n  tkconfigure(w, activebackground = activebackground, activeforeground = activeforeground)\n  class(w) <- c(\"tk2menu\", \"tk2widget\", class(w))\n  return(w)\n}\n\nhasProgram <- function(program, version, prefix=\"--\", line=1, compare=`>=`){\n    # Args:\n    #   program: quoted name of program\n    #   version: quoted version number (numerals . -)\n    #   prefix:  for version switch\n    #   line:    output line containing version number\n    #   compare: comparison operator for version\n    # Example: hasProgram(\"pandoc\", version=\"1.12\")\n    path <- Sys.which(program)\n    present <-  path != \"\"\n    if (missing(version) || !present) return(as.vector(present))\n    result <- try(system2(path, args=paste(prefix, \"version\", sep=\"\"), stderr=TRUE, stdout=TRUE),\n        silent=TRUE)\n    if (inherits(result, \"try-error\")){\n        warning(\"could not execute '\", path, \" --version'\")\n        return(FALSE)\n    }\n    result <- result[line]\n    match <- regexpr(\"((?:(\\\\d+)[\\\\.-])?)*(\\\\*|\\\\d+)\", result)\n    if (match == -1) {\n        warning(\"could not locate version number in\\n\", result)\n        return(FALSE)\n    }\n    result <- substr(result, match, match + attr(match, \"match.length\") - 1)\n    compare(result, version)\n}\n\nRcmdrCapabilities <- function(check=list(c(\"pdflatex\"), c(\"pandoc\", version=\"1.12.3\"))){\n    result <- vector(length(check), mode=\"list\")\n    names(result) <- sapply(check, function(x) x[1])\n    for (i in 1:length(check)){\n        result[[i]] <- do.call(hasProgram, as.list(check[[i]]))\n    }\n    result\n}\n\nbrowsePDF <- function(file) {\n    if (WindowsP()) shell.exec(file)\n    else if (MacOSXP()) system(paste(\"open -a Preview\", shQuote(file)))\n    else system(paste(shQuote(getOption(\"pdfviewer\")), shQuote(file)), wait=FALSE)\n}\n\n# function to insure that \"levels\" of character variables are returned\n\nlevels.character <- function(x) sort(unique(x))\n\n",
    "created" : 1483474643525.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1333649793",
    "id" : "EA2B26A2",
    "lastKnownWriteTime" : 1472135132,
    "last_content_update" : 1472135132,
    "path" : "D:/R-package-sources/Rcmdr-svn/Rcmdr-current/R/utilities.R",
    "project_path" : "R/utilities.R",
    "properties" : {
        "chunk_rendered_width" : "650",
        "source_window_id" : ""
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}